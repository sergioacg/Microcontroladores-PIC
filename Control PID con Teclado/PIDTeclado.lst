CCS PCM C Compiler, Version 5.076, 5967               04-May-20 21:42

               Filename:   C:\Users\Sergio\Google Drive\Projects\PIDTeclado\PIDTeclado.lst

               ROM used:   4340 words (53%)
                           Largest free fragment is 2048
               RAM used:   121 (33%) at main() level
                           139 (38%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #INCLUDE <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  BCF    0A.0
000D:  BCF    0A.1
000E:  BCF    0A.2
000F:  ADDWF  02,F
0010:  RETLW  31
0011:  RETLW  32
0012:  RETLW  33
0013:  RETLW  41
0014:  RETLW  34
0015:  RETLW  35
0016:  RETLW  36
0017:  RETLW  42
0018:  RETLW  37
0019:  RETLW  38
001A:  RETLW  39
001B:  RETLW  43
001C:  RETLW  2A
001D:  RETLW  30
001E:  RETLW  23
001F:  RETLW  44
0020:  DATA 0C,00
0021:  DATA C3,27
0022:  DATA 4E,2A
0023:  DATA D2,27
0024:  DATA 4C,10
0025:  DATA D0,24
0026:  DATA 44,10
0027:  DATA C8,27
0028:  DATA 52,27
0029:  DATA 4F,00
002A:  DATA D3,32
002B:  DATA F4,16
002C:  DATA D0,37
002D:  DATA 69,37
002E:  DATA 74,10
002F:  DATA 20,1D
0030:  DATA A0,12
0031:  DATA 33,17
0032:  DATA 31,33
0033:  DATA A0,21
0034:  DATA 20,10
0035:  DATA 20,00
0036:  DATA D4,32
0037:  DATA 6D,38
0038:  DATA 65,39
0039:  DATA 61,3A
003A:  DATA 75,39
003B:  DATA 61,1D
003C:  DATA A0,12
003D:  DATA 33,17
003E:  DATA 31,33
003F:  DATA A0,21
0040:  DATA 00,01
0041:  DATA CC,32
0042:  DATA 79,10
0043:  DATA C3,37
0044:  DATA 6E,3A
0045:  DATA F2,37
0046:  DATA 6C,1D
0047:  DATA A0,12
0048:  DATA 6C,32
0049:  DATA 20,10
004A:  DATA 20,00
004B:  DATA D2,32
004C:  DATA E6,32
004D:  DATA F2,32
004E:  DATA EE,31
004F:  DATA E9,30
0050:  DATA 28,18
0051:  DATA AD,19
0052:  DATA 30,18
0053:  DATA 29,1D
0054:  DATA 00,01
0055:  DATA 79,10
0056:  DATA 70,39
0057:  DATA E5,39
0058:  DATA E9,37
0059:  DATA EE,32
005A:  DATA 20,15
005B:  DATA 00,01
005C:  DATA 53,28
005D:  DATA 3A,10
005E:  DATA 20,10
005F:  DATA 20,10
0060:  DATA 20,10
0061:  DATA 20,10
0062:  DATA 20,10
0063:  DATA 20,10
0064:  DATA 20,10
0065:  DATA 20,10
0066:  DATA 20,10
0067:  DATA 20,10
0068:  DATA 00,01
0069:  DATA 53,28
006A:  DATA 3A,10
006B:  DATA A5,19
006C:  DATA AE,18
006D:  DATA 66,10
006E:  DATA 20,10
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 20,10
0072:  DATA 00,01
0073:  DATA 0C,00
*
013E:  BSF    0A.0
013F:  BCF    0A.1
0140:  BCF    0A.2
0141:  ADDWF  02,F
0142:  GOTO   124
0143:  GOTO   128
0144:  GOTO   12C
0145:  GOTO   130
*
017B:  MOVF   0B,W
017C:  BSF    03.5
017D:  MOVWF  2D
017E:  BCF    03.5
017F:  BCF    0B.7
0180:  BSF    03.5
0181:  BSF    03.6
0182:  BSF    0C.7
0183:  BSF    0C.0
0184:  NOP
0185:  NOP
0186:  BCF    03.6
0187:  BTFSS  2D.7
0188:  GOTO   18C
0189:  BCF    03.5
018A:  BSF    0B.7
018B:  BSF    03.5
018C:  BCF    03.5
018D:  BSF    03.6
018E:  MOVF   0C,W
018F:  ANDLW  7F
0190:  BTFSC  03.2
0191:  GOTO   1ED
0192:  BSF    03.5
0193:  BCF    03.6
0194:  MOVWF  2D
0195:  BCF    03.5
0196:  BSF    03.6
0197:  MOVF   0D,W
0198:  BSF    03.5
0199:  BCF    03.6
019A:  MOVWF  2E
019B:  BCF    03.5
019C:  BSF    03.6
019D:  MOVF   0F,W
019E:  BSF    03.5
019F:  BCF    03.6
01A0:  MOVWF  2F
01A1:  MOVF   2D,W
01A2:  MOVWF  3E
01A3:  BCF    03.5
01A4:  CALL   146
01A5:  BSF    03.5
01A6:  MOVF   2E,W
01A7:  BCF    03.5
01A8:  BSF    03.6
01A9:  MOVWF  0D
01AA:  BSF    03.5
01AB:  BCF    03.6
01AC:  MOVF   2F,W
01AD:  BCF    03.5
01AE:  BSF    03.6
01AF:  MOVWF  0F
01B0:  BCF    03.6
01B1:  MOVF   0B,W
01B2:  BSF    03.5
01B3:  MOVWF  30
01B4:  BCF    03.5
01B5:  BCF    0B.7
01B6:  BSF    03.5
01B7:  BSF    03.6
01B8:  BSF    0C.7
01B9:  BSF    0C.0
01BA:  NOP
01BB:  NOP
01BC:  BCF    03.6
01BD:  BTFSS  30.7
01BE:  GOTO   1C2
01BF:  BCF    03.5
01C0:  BSF    0B.7
01C1:  BSF    03.5
01C2:  BCF    03.5
01C3:  BSF    03.6
01C4:  RLF    0C,W
01C5:  RLF    0E,W
01C6:  ANDLW  7F
01C7:  BTFSC  03.2
01C8:  GOTO   1ED
01C9:  BSF    03.5
01CA:  BCF    03.6
01CB:  MOVWF  2D
01CC:  BCF    03.5
01CD:  BSF    03.6
01CE:  MOVF   0D,W
01CF:  BSF    03.5
01D0:  BCF    03.6
01D1:  MOVWF  2E
01D2:  BCF    03.5
01D3:  BSF    03.6
01D4:  MOVF   0F,W
01D5:  BSF    03.5
01D6:  BCF    03.6
01D7:  MOVWF  2F
01D8:  MOVF   2D,W
01D9:  MOVWF  3E
01DA:  BCF    03.5
01DB:  CALL   146
01DC:  BSF    03.5
01DD:  MOVF   2E,W
01DE:  BCF    03.5
01DF:  BSF    03.6
01E0:  MOVWF  0D
01E1:  BSF    03.5
01E2:  BCF    03.6
01E3:  MOVF   2F,W
01E4:  BCF    03.5
01E5:  BSF    03.6
01E6:  MOVWF  0F
01E7:  INCF   0D,F
01E8:  BTFSC  03.2
01E9:  INCF   0F,F
01EA:  BCF    03.6
01EB:  GOTO   17B
01EC:  BSF    03.6
01ED:  BCF    03.6
01EE:  RETURN
01EF:  BSF    03.5
01F0:  MOVF   39,W
01F1:  BTFSC  03.2
01F2:  GOTO   2B5
01F3:  MOVWF  45
01F4:  MOVF   3D,W
01F5:  BTFSC  03.2
01F6:  GOTO   2B5
01F7:  SUBWF  45,F
01F8:  BTFSS  03.0
01F9:  GOTO   1FF
01FA:  MOVLW  7F
01FB:  ADDWF  45,F
01FC:  BTFSC  03.0
01FD:  GOTO   2B5
01FE:  GOTO   205
01FF:  MOVLW  81
0200:  SUBWF  45,F
0201:  BTFSS  03.0
0202:  GOTO   2B5
0203:  BTFSC  03.2
0204:  GOTO   2B5
0205:  MOVF   45,W
0206:  MOVWF  77
0207:  CLRF   78
0208:  CLRF   79
0209:  CLRF   7A
020A:  CLRF   44
020B:  MOVF   3A,W
020C:  MOVWF  43
020D:  BSF    43.7
020E:  MOVF   3B,W
020F:  MOVWF  42
0210:  MOVF   3C,W
0211:  MOVWF  41
0212:  MOVLW  19
0213:  MOVWF  45
0214:  MOVF   40,W
0215:  SUBWF  41,F
0216:  BTFSC  03.0
0217:  GOTO   228
0218:  MOVLW  01
0219:  SUBWF  42,F
021A:  BTFSC  03.0
021B:  GOTO   228
021C:  SUBWF  43,F
021D:  BTFSC  03.0
021E:  GOTO   228
021F:  SUBWF  44,F
0220:  BTFSC  03.0
0221:  GOTO   228
0222:  INCF   44,F
0223:  INCF   43,F
0224:  INCF   42,F
0225:  MOVF   40,W
0226:  ADDWF  41,F
0227:  GOTO   25A
0228:  MOVF   3F,W
0229:  SUBWF  42,F
022A:  BTFSC  03.0
022B:  GOTO   243
022C:  MOVLW  01
022D:  SUBWF  43,F
022E:  BTFSC  03.0
022F:  GOTO   243
0230:  SUBWF  44,F
0231:  BTFSC  03.0
0232:  GOTO   243
0233:  INCF   44,F
0234:  INCF   43,F
0235:  MOVF   3F,W
0236:  ADDWF  42,F
0237:  MOVF   40,W
0238:  ADDWF  41,F
0239:  BTFSS  03.0
023A:  GOTO   25A
023B:  INCF   42,F
023C:  BTFSS  03.2
023D:  GOTO   25A
023E:  INCF   43,F
023F:  BTFSS  03.2
0240:  GOTO   25A
0241:  INCF   44,F
0242:  GOTO   25A
0243:  MOVF   3E,W
0244:  IORLW  80
0245:  SUBWF  43,F
0246:  BTFSC  03.0
0247:  GOTO   259
0248:  MOVLW  01
0249:  SUBWF  44,F
024A:  BTFSC  03.0
024B:  GOTO   259
024C:  INCF   44,F
024D:  MOVF   3E,W
024E:  IORLW  80
024F:  ADDWF  43,F
0250:  MOVF   3F,W
0251:  ADDWF  42,F
0252:  BTFSS  03.0
0253:  GOTO   237
0254:  INCF   43,F
0255:  BTFSS  03.2
0256:  GOTO   237
0257:  INCF   44,F
0258:  GOTO   237
0259:  BSF    7A.0
025A:  DECFSZ 45,F
025B:  GOTO   25D
025C:  GOTO   268
025D:  BCF    03.0
025E:  RLF    41,F
025F:  RLF    42,F
0260:  RLF    43,F
0261:  RLF    44,F
0262:  BCF    03.0
0263:  RLF    7A,F
0264:  RLF    79,F
0265:  RLF    78,F
0266:  RLF    46,F
0267:  GOTO   214
0268:  BTFSS  46.0
0269:  GOTO   270
026A:  BCF    03.0
026B:  RRF    78,F
026C:  RRF    79,F
026D:  RRF    7A,F
026E:  RRF    46,F
026F:  GOTO   273
0270:  DECF   77,F
0271:  BTFSC  03.2
0272:  GOTO   2B5
0273:  BTFSC  46.7
0274:  GOTO   29C
0275:  BCF    03.0
0276:  RLF    41,F
0277:  RLF    42,F
0278:  RLF    43,F
0279:  RLF    44,F
027A:  MOVF   40,W
027B:  SUBWF  41,F
027C:  BTFSC  03.0
027D:  GOTO   288
027E:  MOVLW  01
027F:  SUBWF  42,F
0280:  BTFSC  03.0
0281:  GOTO   288
0282:  SUBWF  43,F
0283:  BTFSC  03.0
0284:  GOTO   288
0285:  SUBWF  44,F
0286:  BTFSS  03.0
0287:  GOTO   2AB
0288:  MOVF   3F,W
0289:  SUBWF  42,F
028A:  BTFSC  03.0
028B:  GOTO   293
028C:  MOVLW  01
028D:  SUBWF  43,F
028E:  BTFSC  03.0
028F:  GOTO   293
0290:  SUBWF  44,F
0291:  BTFSS  03.0
0292:  GOTO   2AB
0293:  MOVF   3E,W
0294:  IORLW  80
0295:  SUBWF  43,F
0296:  BTFSC  03.0
0297:  GOTO   29C
0298:  MOVLW  01
0299:  SUBWF  44,F
029A:  BTFSS  03.0
029B:  GOTO   2AB
029C:  INCF   7A,F
029D:  BTFSS  03.2
029E:  GOTO   2AB
029F:  INCF   79,F
02A0:  BTFSS  03.2
02A1:  GOTO   2AB
02A2:  INCF   78,F
02A3:  BTFSS  03.2
02A4:  GOTO   2AB
02A5:  INCF   77,F
02A6:  BTFSC  03.2
02A7:  GOTO   2B5
02A8:  RRF    78,F
02A9:  RRF    79,F
02AA:  RRF    7A,F
02AB:  MOVF   3A,W
02AC:  MOVWF  45
02AD:  MOVF   3E,W
02AE:  XORWF  45,F
02AF:  BTFSS  45.7
02B0:  GOTO   2B3
02B1:  BSF    78.7
02B2:  GOTO   2B9
02B3:  BCF    78.7
02B4:  GOTO   2B9
02B5:  CLRF   77
02B6:  CLRF   78
02B7:  CLRF   79
02B8:  CLRF   7A
02B9:  BCF    03.5
02BA:  RETURN
02BB:  BSF    03.5
02BC:  MOVF   3E,W
02BD:  BTFSC  03.2
02BE:  GOTO   32C
02BF:  MOVWF  46
02C0:  MOVF   42,W
02C1:  BTFSC  03.2
02C2:  GOTO   32C
02C3:  ADDWF  46,F
02C4:  BTFSC  03.0
02C5:  GOTO   2CD
02C6:  MOVLW  7F
02C7:  SUBWF  46,F
02C8:  BTFSS  03.0
02C9:  GOTO   32C
02CA:  BTFSC  03.2
02CB:  GOTO   32C
02CC:  GOTO   2D1
02CD:  MOVLW  81
02CE:  ADDWF  46,F
02CF:  BTFSC  03.0
02D0:  GOTO   32C
02D1:  MOVF   46,W
02D2:  MOVWF  77
02D3:  CLRF   78
02D4:  CLRF   79
02D5:  CLRF   7A
02D6:  MOVF   3F,W
02D7:  MOVWF  4A
02D8:  BSF    4A.7
02D9:  MOVF   40,W
02DA:  MOVWF  49
02DB:  MOVF   41,W
02DC:  MOVWF  48
02DD:  MOVLW  18
02DE:  MOVWF  46
02DF:  CLRF   47
02E0:  BTFSS  48.0
02E1:  GOTO   2FA
02E2:  MOVF   45,W
02E3:  ADDWF  7A,F
02E4:  BTFSS  03.0
02E5:  GOTO   2EC
02E6:  INCF   79,F
02E7:  BTFSS  03.2
02E8:  GOTO   2EC
02E9:  INCF   78,F
02EA:  BTFSC  03.2
02EB:  BSF    47.7
02EC:  MOVF   44,W
02ED:  ADDWF  79,F
02EE:  BTFSS  03.0
02EF:  GOTO   2F3
02F0:  INCF   78,F
02F1:  BTFSC  03.2
02F2:  BSF    47.7
02F3:  MOVF   43,W
02F4:  MOVWF  40
02F5:  BSF    40.7
02F6:  MOVF   40,W
02F7:  ADDWF  78,F
02F8:  BTFSC  03.0
02F9:  BSF    47.7
02FA:  RLF    47,F
02FB:  RRF    78,F
02FC:  RRF    79,F
02FD:  RRF    7A,F
02FE:  RRF    4A,F
02FF:  RRF    49,F
0300:  RRF    48,F
0301:  BCF    03.0
0302:  DECFSZ 46,F
0303:  GOTO   2DF
0304:  MOVLW  01
0305:  ADDWF  77,F
0306:  BTFSC  03.0
0307:  GOTO   32C
0308:  BTFSC  78.7
0309:  GOTO   311
030A:  RLF    4A,F
030B:  RLF    7A,F
030C:  RLF    79,F
030D:  RLF    78,F
030E:  DECF   77,F
030F:  BTFSC  03.2
0310:  GOTO   32C
0311:  BTFSS  4A.7
0312:  GOTO   322
0313:  INCF   7A,F
0314:  BTFSS  03.2
0315:  GOTO   322
0316:  INCF   79,F
0317:  BTFSS  03.2
0318:  GOTO   322
0319:  INCF   78,F
031A:  BTFSS  03.2
031B:  GOTO   322
031C:  RRF    78,F
031D:  RRF    79,F
031E:  RRF    7A,F
031F:  INCF   77,F
0320:  BTFSC  03.2
0321:  GOTO   32C
0322:  MOVF   3F,W
0323:  MOVWF  47
0324:  MOVF   43,W
0325:  XORWF  47,F
0326:  BTFSS  47.7
0327:  GOTO   32A
0328:  BSF    78.7
0329:  GOTO   330
032A:  BCF    78.7
032B:  GOTO   330
032C:  CLRF   77
032D:  CLRF   78
032E:  CLRF   79
032F:  CLRF   7A
0330:  BCF    03.5
0331:  RETURN
0332:  MOVLW  80
0333:  BTFSS  03.1
0334:  GOTO   338
0335:  BSF    03.5
0336:  XORWF  3A,F
0337:  BCF    03.5
0338:  BSF    03.5
0339:  CLRF   3F
033A:  CLRF   40
033B:  MOVF   36,W
033C:  MOVWF  3E
033D:  MOVF   3A,W
033E:  XORWF  3E,F
033F:  MOVF   35,W
0340:  BTFSC  03.2
0341:  GOTO   426
0342:  MOVWF  3D
0343:  MOVWF  77
0344:  MOVF   39,W
0345:  BTFSC  03.2
0346:  GOTO   42F
0347:  SUBWF  3D,F
0348:  BTFSC  03.2
0349:  GOTO   3CB
034A:  BTFSS  03.0
034B:  GOTO   389
034C:  MOVF   3A,W
034D:  MOVWF  43
034E:  BSF    43.7
034F:  MOVF   3B,W
0350:  MOVWF  42
0351:  MOVF   3C,W
0352:  MOVWF  41
0353:  CLRF   40
0354:  BCF    03.0
0355:  RRF    43,F
0356:  RRF    42,F
0357:  RRF    41,F
0358:  RRF    40,F
0359:  DECFSZ 3D,F
035A:  GOTO   353
035B:  BTFSS  3E.7
035C:  GOTO   360
035D:  BSF    3F.0
035E:  GOTO   443
035F:  BCF    3F.0
0360:  BCF    3D.0
0361:  BSF    3F.4
0362:  MOVLW  B8
0363:  MOVWF  04
0364:  BCF    03.7
0365:  GOTO   458
0366:  BCF    3F.4
0367:  BTFSC  3E.7
0368:  GOTO   373
0369:  BTFSS  3D.0
036A:  GOTO   37E
036B:  RRF    43,F
036C:  RRF    42,F
036D:  RRF    41,F
036E:  RRF    40,F
036F:  INCF   77,F
0370:  BTFSC  03.2
0371:  GOTO   43E
0372:  GOTO   37E
0373:  BTFSC  43.7
0374:  GOTO   381
0375:  BCF    03.0
0376:  RLF    40,F
0377:  RLF    41,F
0378:  RLF    42,F
0379:  RLF    43,F
037A:  DECF   77,F
037B:  BTFSC  03.2
037C:  GOTO   43E
037D:  GOTO   373
037E:  BSF    3F.6
037F:  GOTO   3EB
0380:  BCF    3F.6
0381:  MOVF   36,W
0382:  MOVWF  3E
0383:  BTFSS  3E.7
0384:  GOTO   387
0385:  BSF    43.7
0386:  GOTO   437
0387:  BCF    43.7
0388:  GOTO   437
0389:  MOVF   39,W
038A:  MOVWF  3D
038B:  MOVWF  77
038C:  MOVF   35,W
038D:  SUBWF  3D,F
038E:  MOVF   36,W
038F:  MOVWF  43
0390:  BSF    43.7
0391:  MOVF   37,W
0392:  MOVWF  42
0393:  MOVF   38,W
0394:  MOVWF  41
0395:  CLRF   40
0396:  BCF    03.0
0397:  RRF    43,F
0398:  RRF    42,F
0399:  RRF    41,F
039A:  RRF    40,F
039B:  DECFSZ 3D,F
039C:  GOTO   395
039D:  BTFSS  3E.7
039E:  GOTO   3A2
039F:  BSF    3F.1
03A0:  GOTO   443
03A1:  BCF    3F.1
03A2:  BCF    3D.0
03A3:  BSF    3F.5
03A4:  MOVLW  BC
03A5:  MOVWF  04
03A6:  BCF    03.7
03A7:  GOTO   458
03A8:  BCF    3F.5
03A9:  BTFSC  3E.7
03AA:  GOTO   3B5
03AB:  BTFSS  3D.0
03AC:  GOTO   3C0
03AD:  RRF    43,F
03AE:  RRF    42,F
03AF:  RRF    41,F
03B0:  RRF    40,F
03B1:  INCF   77,F
03B2:  BTFSC  03.2
03B3:  GOTO   43E
03B4:  GOTO   3C0
03B5:  BTFSC  43.7
03B6:  GOTO   3C3
03B7:  BCF    03.0
03B8:  RLF    40,F
03B9:  RLF    41,F
03BA:  RLF    42,F
03BB:  RLF    43,F
03BC:  DECF   77,F
03BD:  BTFSC  03.2
03BE:  GOTO   43E
03BF:  GOTO   3B5
03C0:  BSF    3F.7
03C1:  GOTO   3EB
03C2:  BCF    3F.7
03C3:  MOVF   3A,W
03C4:  MOVWF  3E
03C5:  BTFSS  3E.7
03C6:  GOTO   3C9
03C7:  BSF    43.7
03C8:  GOTO   437
03C9:  BCF    43.7
03CA:  GOTO   437
03CB:  MOVF   3A,W
03CC:  MOVWF  43
03CD:  BSF    43.7
03CE:  MOVF   3B,W
03CF:  MOVWF  42
03D0:  MOVF   3C,W
03D1:  MOVWF  41
03D2:  BTFSS  3E.7
03D3:  GOTO   3D8
03D4:  BCF    43.7
03D5:  BSF    3F.2
03D6:  GOTO   443
03D7:  BCF    3F.2
03D8:  CLRF   40
03D9:  BCF    3D.0
03DA:  MOVLW  B8
03DB:  MOVWF  04
03DC:  BCF    03.7
03DD:  GOTO   458
03DE:  BTFSC  3E.7
03DF:  GOTO   401
03E0:  MOVF   36,W
03E1:  MOVWF  3E
03E2:  BTFSS  3D.0
03E3:  GOTO   3EB
03E4:  RRF    43,F
03E5:  RRF    42,F
03E6:  RRF    41,F
03E7:  RRF    40,F
03E8:  INCF   77,F
03E9:  BTFSC  03.2
03EA:  GOTO   43E
03EB:  BTFSS  40.7
03EC:  GOTO   3FC
03ED:  INCF   41,F
03EE:  BTFSS  03.2
03EF:  GOTO   3FC
03F0:  INCF   42,F
03F1:  BTFSS  03.2
03F2:  GOTO   3FC
03F3:  INCF   43,F
03F4:  BTFSS  03.2
03F5:  GOTO   3FC
03F6:  RRF    43,F
03F7:  RRF    42,F
03F8:  RRF    41,F
03F9:  INCF   77,F
03FA:  BTFSC  03.2
03FB:  GOTO   43E
03FC:  BTFSC  3F.6
03FD:  GOTO   380
03FE:  BTFSC  3F.7
03FF:  GOTO   3C2
0400:  GOTO   420
0401:  MOVLW  80
0402:  XORWF  43,F
0403:  BTFSS  43.7
0404:  GOTO   409
0405:  GOTO   443
0406:  MOVF   3A,W
0407:  MOVWF  3E
0408:  GOTO   416
0409:  MOVF   36,W
040A:  MOVWF  3E
040B:  MOVF   43,F
040C:  BTFSS  03.2
040D:  GOTO   416
040E:  MOVF   42,F
040F:  BTFSS  03.2
0410:  GOTO   416
0411:  MOVF   41,F
0412:  BTFSS  03.2
0413:  GOTO   416
0414:  CLRF   77
0415:  GOTO   437
0416:  BTFSC  43.7
0417:  GOTO   420
0418:  BCF    03.0
0419:  RLF    40,F
041A:  RLF    41,F
041B:  RLF    42,F
041C:  RLF    43,F
041D:  DECFSZ 77,F
041E:  GOTO   416
041F:  GOTO   43E
0420:  BTFSS  3E.7
0421:  GOTO   424
0422:  BSF    43.7
0423:  GOTO   437
0424:  BCF    43.7
0425:  GOTO   437
0426:  MOVF   39,W
0427:  MOVWF  77
0428:  MOVF   3A,W
0429:  MOVWF  43
042A:  MOVF   3B,W
042B:  MOVWF  42
042C:  MOVF   3C,W
042D:  MOVWF  41
042E:  GOTO   437
042F:  MOVF   35,W
0430:  MOVWF  77
0431:  MOVF   36,W
0432:  MOVWF  43
0433:  MOVF   37,W
0434:  MOVWF  42
0435:  MOVF   38,W
0436:  MOVWF  41
0437:  MOVF   43,W
0438:  MOVWF  78
0439:  MOVF   42,W
043A:  MOVWF  79
043B:  MOVF   41,W
043C:  MOVWF  7A
043D:  GOTO   476
043E:  CLRF   77
043F:  CLRF   78
0440:  CLRF   79
0441:  CLRF   7A
0442:  GOTO   476
0443:  CLRF   40
0444:  COMF   41,F
0445:  COMF   42,F
0446:  COMF   43,F
0447:  COMF   40,F
0448:  INCF   40,F
0449:  BTFSS  03.2
044A:  GOTO   451
044B:  INCF   41,F
044C:  BTFSS  03.2
044D:  GOTO   451
044E:  INCF   42,F
044F:  BTFSC  03.2
0450:  INCF   43,F
0451:  BTFSC  3F.0
0452:  GOTO   35F
0453:  BTFSC  3F.1
0454:  GOTO   3A1
0455:  BTFSC  3F.2
0456:  GOTO   3D7
0457:  GOTO   406
0458:  MOVF   00,W
0459:  ADDWF  41,F
045A:  BTFSS  03.0
045B:  GOTO   462
045C:  INCF   42,F
045D:  BTFSS  03.2
045E:  GOTO   462
045F:  INCF   43,F
0460:  BTFSC  03.2
0461:  BSF    3D.0
0462:  DECF   04,F
0463:  MOVF   00,W
0464:  ADDWF  42,F
0465:  BTFSS  03.0
0466:  GOTO   46A
0467:  INCF   43,F
0468:  BTFSC  03.2
0469:  BSF    3D.0
046A:  DECF   04,F
046B:  MOVF   00,W
046C:  BTFSS  00.7
046D:  XORLW  80
046E:  ADDWF  43,F
046F:  BTFSC  03.0
0470:  BSF    3D.0
0471:  BTFSC  3F.4
0472:  GOTO   366
0473:  BTFSC  3F.5
0474:  GOTO   3A8
0475:  GOTO   3DE
0476:  BCF    03.5
0477:  RETURN
0478:  MOVLW  8E
0479:  MOVWF  77
047A:  BSF    03.5
047B:  MOVF   2E,W
047C:  MOVWF  78
047D:  MOVF   2D,W
047E:  MOVWF  79
047F:  CLRF   7A
0480:  MOVF   78,F
0481:  BTFSS  03.2
0482:  GOTO   48D
0483:  MOVF   79,W
0484:  MOVWF  78
0485:  CLRF   79
0486:  MOVLW  08
0487:  SUBWF  77,F
0488:  MOVF   78,F
0489:  BTFSS  03.2
048A:  GOTO   48D
048B:  CLRF   77
048C:  GOTO   495
048D:  BCF    03.0
048E:  BTFSC  78.7
048F:  GOTO   494
0490:  RLF    79,F
0491:  RLF    78,F
0492:  DECF   77,F
0493:  GOTO   48D
0494:  BCF    78.7
0495:  BCF    03.5
0496:  RETURN
0497:  BSF    03.5
0498:  MOVF   2E,W
0499:  MOVWF  35
049A:  MOVF   32,W
049B:  XORWF  35,F
049C:  BTFSS  35.7
049D:  GOTO   4A3
049E:  BCF    03.2
049F:  BCF    03.0
04A0:  BTFSC  2E.7
04A1:  BSF    03.0
04A2:  GOTO   4D6
04A3:  MOVF   2E,W
04A4:  MOVWF  35
04A5:  MOVF   31,W
04A6:  MOVWF  36
04A7:  MOVF   2D,W
04A8:  SUBWF  36,F
04A9:  BTFSC  03.2
04AA:  GOTO   4B1
04AB:  BTFSS  35.7
04AC:  GOTO   4D6
04AD:  MOVF   03,W
04AE:  XORLW  01
04AF:  MOVWF  03
04B0:  GOTO   4D6
04B1:  MOVF   32,W
04B2:  MOVWF  36
04B3:  MOVF   2E,W
04B4:  SUBWF  36,F
04B5:  BTFSC  03.2
04B6:  GOTO   4BD
04B7:  BTFSS  35.7
04B8:  GOTO   4D6
04B9:  MOVF   03,W
04BA:  XORLW  01
04BB:  MOVWF  03
04BC:  GOTO   4D6
04BD:  MOVF   33,W
04BE:  MOVWF  36
04BF:  MOVF   2F,W
04C0:  SUBWF  36,F
04C1:  BTFSC  03.2
04C2:  GOTO   4C9
04C3:  BTFSS  35.7
04C4:  GOTO   4D6
04C5:  MOVF   03,W
04C6:  XORLW  01
04C7:  MOVWF  03
04C8:  GOTO   4D6
04C9:  MOVF   34,W
04CA:  MOVWF  36
04CB:  MOVF   30,W
04CC:  SUBWF  36,F
04CD:  BTFSC  03.2
04CE:  GOTO   4D5
04CF:  BTFSS  35.7
04D0:  GOTO   4D6
04D1:  MOVF   03,W
04D2:  XORLW  01
04D3:  MOVWF  03
04D4:  GOTO   4D6
04D5:  BCF    03.0
04D6:  BCF    03.5
04D7:  RETURN
*
0635:  MOVLW  8E
0636:  MOVWF  77
0637:  MOVF   2D,W
0638:  SUBWF  77,F
0639:  MOVF   2E,W
063A:  MOVWF  79
063B:  MOVF   2F,W
063C:  MOVWF  78
063D:  BSF    79.7
063E:  MOVF   77,F
063F:  BTFSC  03.2
0640:  GOTO   64C
0641:  BCF    03.0
0642:  MOVF   79,F
0643:  BTFSS  03.2
0644:  GOTO   648
0645:  MOVF   78,F
0646:  BTFSC  03.2
0647:  GOTO   64C
0648:  RRF    79,F
0649:  RRF    78,F
064A:  DECFSZ 77,F
064B:  GOTO   641
064C:  BTFSS  2E.7
064D:  GOTO   653
064E:  COMF   78,F
064F:  COMF   79,F
0650:  INCF   78,F
0651:  BTFSC  03.2
0652:  INCF   79,F
*
0686:  MOVF   0B,W
0687:  BSF    03.5
0688:  MOVWF  32
0689:  BCF    03.5
068A:  BCF    0B.7
068B:  BSF    03.5
068C:  BSF    03.6
068D:  BSF    0C.7
068E:  BSF    0C.0
068F:  NOP
0690:  NOP
0691:  BCF    03.6
0692:  BTFSS  32.7
0693:  GOTO   697
0694:  BCF    03.5
0695:  BSF    0B.7
0696:  BSF    03.5
0697:  BTFSC  03.0
0698:  GOTO   6D0
0699:  BCF    03.5
069A:  BSF    03.6
069B:  MOVF   0C,W
069C:  ANDLW  7F
069D:  BSF    03.5
069E:  BCF    03.6
069F:  MOVWF  32
06A0:  BCF    03.5
06A1:  BSF    03.6
06A2:  MOVF   0D,W
06A3:  BSF    03.5
06A4:  BCF    03.6
06A5:  MOVWF  33
06A6:  BCF    03.5
06A7:  BSF    03.6
06A8:  MOVF   0F,W
06A9:  BSF    03.5
06AA:  BCF    03.6
06AB:  MOVWF  34
06AC:  MOVF   32,W
06AD:  MOVWF  3E
06AE:  BCF    03.5
06AF:  CALL   146
06B0:  BSF    03.5
06B1:  MOVF   33,W
06B2:  BCF    03.5
06B3:  BSF    03.6
06B4:  MOVWF  0D
06B5:  BSF    03.5
06B6:  BCF    03.6
06B7:  MOVF   34,W
06B8:  BCF    03.5
06B9:  BSF    03.6
06BA:  MOVWF  0F
06BB:  BCF    03.6
06BC:  MOVF   0B,W
06BD:  BSF    03.5
06BE:  MOVWF  35
06BF:  BCF    03.5
06C0:  BCF    0B.7
06C1:  BSF    03.5
06C2:  BSF    03.6
06C3:  BSF    0C.7
06C4:  BSF    0C.0
06C5:  NOP
06C6:  NOP
06C7:  BCF    03.6
06C8:  BTFSS  35.7
06C9:  GOTO   6CD
06CA:  BCF    03.5
06CB:  BSF    0B.7
06CC:  BSF    03.5
06CD:  DECFSZ 31,F
06CE:  GOTO   6D0
06CF:  GOTO   6FE
06D0:  BCF    03.5
06D1:  BSF    03.6
06D2:  RLF    0C,W
06D3:  RLF    0E,W
06D4:  ANDLW  7F
06D5:  BSF    03.5
06D6:  BCF    03.6
06D7:  MOVWF  32
06D8:  BCF    03.5
06D9:  BSF    03.6
06DA:  MOVF   0D,W
06DB:  BSF    03.5
06DC:  BCF    03.6
06DD:  MOVWF  33
06DE:  BCF    03.5
06DF:  BSF    03.6
06E0:  MOVF   0F,W
06E1:  BSF    03.5
06E2:  BCF    03.6
06E3:  MOVWF  34
06E4:  MOVF   32,W
06E5:  MOVWF  3E
06E6:  BCF    03.5
06E7:  CALL   146
06E8:  BSF    03.5
06E9:  MOVF   33,W
06EA:  BCF    03.5
06EB:  BSF    03.6
06EC:  MOVWF  0D
06ED:  BSF    03.5
06EE:  BCF    03.6
06EF:  MOVF   34,W
06F0:  BCF    03.5
06F1:  BSF    03.6
06F2:  MOVWF  0F
06F3:  INCF   0D,F
06F4:  BTFSC  03.2
06F5:  INCF   0F,F
06F6:  BCF    03.0
06F7:  BSF    03.5
06F8:  BCF    03.6
06F9:  DECFSZ 31,F
06FA:  GOTO   6FC
06FB:  GOTO   6FE
06FC:  BCF    03.5
06FD:  GOTO   686
06FE:  BCF    03.5
06FF:  RETURN
0700:  BTFSC  03.1
0701:  GOTO   705
0702:  MOVLW  C6
0703:  MOVWF  04
0704:  BCF    03.7
0705:  CLRF   77
0706:  CLRF   78
0707:  CLRF   79
0708:  CLRF   7A
0709:  BSF    03.5
070A:  CLRF   46
070B:  CLRF   47
070C:  CLRF   48
070D:  CLRF   49
070E:  MOVF   45,W
070F:  IORWF  44,W
0710:  IORWF  43,W
0711:  IORWF  42,W
0712:  BTFSC  03.2
0713:  GOTO   744
0714:  MOVLW  20
0715:  MOVWF  4A
0716:  BCF    03.0
0717:  RLF    3E,F
0718:  RLF    3F,F
0719:  RLF    40,F
071A:  RLF    41,F
071B:  RLF    46,F
071C:  RLF    47,F
071D:  RLF    48,F
071E:  RLF    49,F
071F:  MOVF   45,W
0720:  SUBWF  49,W
0721:  BTFSS  03.2
0722:  GOTO   72D
0723:  MOVF   44,W
0724:  SUBWF  48,W
0725:  BTFSS  03.2
0726:  GOTO   72D
0727:  MOVF   43,W
0728:  SUBWF  47,W
0729:  BTFSS  03.2
072A:  GOTO   72D
072B:  MOVF   42,W
072C:  SUBWF  46,W
072D:  BTFSS  03.0
072E:  GOTO   73E
072F:  MOVF   42,W
0730:  SUBWF  46,F
0731:  MOVF   43,W
0732:  BTFSS  03.0
0733:  INCFSZ 43,W
0734:  SUBWF  47,F
0735:  MOVF   44,W
0736:  BTFSS  03.0
0737:  INCFSZ 44,W
0738:  SUBWF  48,F
0739:  MOVF   45,W
073A:  BTFSS  03.0
073B:  INCFSZ 45,W
073C:  SUBWF  49,F
073D:  BSF    03.0
073E:  RLF    77,F
073F:  RLF    78,F
0740:  RLF    79,F
0741:  RLF    7A,F
0742:  DECFSZ 4A,F
0743:  GOTO   716
0744:  MOVF   46,W
0745:  MOVWF  00
0746:  INCF   04,F
0747:  MOVF   47,W
0748:  MOVWF  00
0749:  INCF   04,F
074A:  MOVF   48,W
074B:  MOVWF  00
074C:  INCF   04,F
074D:  MOVF   49,W
074E:  MOVWF  00
074F:  BCF    03.5
0750:  RETURN
0751:  BSF    03.5
0752:  CLRF   35
0753:  MOVF   04,W
0754:  MOVWF  34
0755:  BCF    35.0
0756:  BTFSC  03.7
0757:  BSF    35.0
0758:  BTFSS  2E.7
0759:  GOTO   762
075A:  BSF    34.7
075B:  BTFSS  34.4
075C:  INCF   34,F
075D:  COMF   2D,F
075E:  COMF   2E,F
075F:  INCF   2D,F
0760:  BTFSC  03.2
0761:  INCF   2E,F
0762:  SWAPF  2E,W
0763:  IORLW  F0
0764:  MOVWF  30
0765:  ADDWF  30,F
0766:  ADDLW  E2
0767:  MOVWF  31
0768:  ADDLW  32
0769:  MOVWF  33
076A:  MOVF   2E,W
076B:  ANDLW  0F
076C:  ADDWF  31,F
076D:  ADDWF  31,F
076E:  ADDWF  33,F
076F:  ADDLW  E9
0770:  MOVWF  32
0771:  ADDWF  32,F
0772:  ADDWF  32,F
0773:  SWAPF  2D,W
0774:  ANDLW  0F
0775:  ADDWF  32,F
0776:  ADDWF  33,F
0777:  RLF    32,F
0778:  RLF    33,F
0779:  COMF   33,F
077A:  RLF    33,F
077B:  MOVF   2D,W
077C:  ANDLW  0F
077D:  ADDWF  33,F
077E:  RLF    30,F
077F:  MOVLW  07
0780:  MOVWF  2F
0781:  MOVLW  0A
0782:  ADDWF  33,F
0783:  DECF   32,F
0784:  BTFSS  03.0
0785:  GOTO   782
0786:  ADDWF  32,F
0787:  DECF   31,F
0788:  BTFSS  03.0
0789:  GOTO   786
078A:  ADDWF  31,F
078B:  DECF   30,F
078C:  BTFSS  03.0
078D:  GOTO   78A
078E:  ADDWF  30,F
078F:  DECF   2F,F
0790:  BTFSS  03.0
0791:  GOTO   78E
0792:  MOVLW  AF
0793:  MOVWF  04
0794:  BCF    03.7
0795:  MOVLW  07
0796:  ANDWF  34,W
0797:  BCF    34.6
0798:  DECF   04,F
0799:  ANDWF  34,W
079A:  BTFSS  03.2
079B:  GOTO   7A3
079C:  BTFSC  34.4
079D:  INCF   04,F
079E:  BTFSC  34.4
079F:  GOTO   7A3
07A0:  MOVLW  20
07A1:  MOVWF  77
07A2:  GOTO   7C0
07A3:  ADDWF  04,F
07A4:  MOVLW  B3
07A5:  SUBWF  04,W
07A6:  BTFSC  03.2
07A7:  BSF    34.6
07A8:  MOVF   00,W
07A9:  MOVWF  77
07AA:  BTFSS  03.2
07AB:  GOTO   7B4
07AC:  BTFSC  34.6
07AD:  GOTO   7B4
07AE:  BTFSC  34.4
07AF:  GOTO   7D0
07B0:  BTFSC  34.3
07B1:  GOTO   7B4
07B2:  MOVLW  20
07B3:  GOTO   7BF
07B4:  BTFSS  34.7
07B5:  GOTO   7BC
07B6:  MOVLW  2D
07B7:  MOVWF  77
07B8:  DECF   04,F
07B9:  BCF    34.6
07BA:  BCF    34.7
07BB:  GOTO   7C0
07BC:  BSF    34.3
07BD:  BCF    34.4
07BE:  MOVLW  30
07BF:  ADDWF  77,F
07C0:  CLRF   2E
07C1:  MOVF   04,W
07C2:  MOVWF  2D
07C3:  BCF    2E.0
07C4:  BTFSC  03.7
07C5:  BSF    2E.0
07C6:  MOVF   77,W
07C7:  MOVWF  3E
07C8:  BCF    03.5
07C9:  CALL   146
07CA:  BSF    03.5
07CB:  MOVF   2D,W
07CC:  MOVWF  04
07CD:  BCF    03.7
07CE:  BTFSC  2E.0
07CF:  BSF    03.7
07D0:  INCF   04,F
07D1:  BTFSS  34.6
07D2:  GOTO   7A4
07D3:  BCF    03.5
07D4:  BCF    0A.3
07D5:  BSF    0A.4
07D6:  GOTO   4CF (RETURN)
*
0800:  MOVF   04,W
0801:  BSF    03.5
0802:  MOVWF  36
0803:  MOVF   35,W
0804:  MOVWF  38
0805:  BTFSC  03.2
0806:  GOTO   024
0807:  MOVF   34,W
0808:  MOVWF  41
0809:  MOVF   33,W
080A:  MOVWF  40
080B:  MOVF   32,W
080C:  MOVWF  3F
080D:  MOVF   31,W
080E:  MOVWF  3E
080F:  CLRF   45
0810:  CLRF   44
0811:  MOVLW  20
0812:  MOVWF  43
0813:  MOVLW  82
0814:  MOVWF  42
0815:  BCF    0A.3
0816:  BCF    03.5
0817:  CALL   2BB
0818:  BSF    0A.3
0819:  MOVF   7A,W
081A:  BSF    03.5
081B:  MOVWF  34
081C:  MOVF   79,W
081D:  MOVWF  33
081E:  MOVF   78,W
081F:  MOVWF  32
0820:  MOVF   77,W
0821:  MOVWF  31
0822:  DECFSZ 38,F
0823:  GOTO   007
0824:  MOVF   34,W
0825:  MOVWF  41
0826:  MOVF   33,W
0827:  MOVWF  40
0828:  MOVF   32,W
0829:  MOVWF  3F
082A:  MOVF   31,W
082B:  MOVWF  3E
082C:  MOVF   3E,W
082D:  SUBLW  B6
082E:  MOVWF  3E
082F:  CLRF   7A
0830:  MOVF   3F,W
0831:  MOVWF  42
0832:  BSF    3F.7
0833:  BCF    03.0
0834:  RRF    3F,F
0835:  RRF    40,F
0836:  RRF    41,F
0837:  RRF    7A,F
0838:  RRF    79,F
0839:  RRF    78,F
083A:  RRF    77,F
083B:  DECFSZ 3E,F
083C:  GOTO   033
083D:  BTFSS  42.7
083E:  GOTO   04A
083F:  COMF   77,F
0840:  COMF   78,F
0841:  COMF   79,F
0842:  COMF   7A,F
0843:  INCF   77,F
0844:  BTFSC  03.2
0845:  INCF   78,F
0846:  BTFSC  03.2
0847:  INCF   79,F
0848:  BTFSC  03.2
0849:  INCF   7A,F
084A:  MOVF   7A,W
084B:  MOVWF  34
084C:  MOVF   79,W
084D:  MOVWF  33
084E:  MOVF   78,W
084F:  MOVWF  32
0850:  MOVF   77,W
0851:  MOVWF  31
0852:  BTFSS  34.7
0853:  GOTO   061
0854:  DECF   36,F
0855:  BSF    36.5
0856:  COMF   31,F
0857:  COMF   32,F
0858:  COMF   33,F
0859:  COMF   34,F
085A:  INCF   31,F
085B:  BTFSC  03.2
085C:  INCF   32,F
085D:  BTFSC  03.2
085E:  INCF   33,F
085F:  BTFSC  03.2
0860:  INCF   34,F
0861:  MOVLW  3B
0862:  MOVWF  3D
0863:  MOVLW  9A
0864:  MOVWF  3C
0865:  MOVLW  CA
0866:  MOVWF  3B
0867:  CLRF   3A
0868:  MOVLW  0A
0869:  MOVWF  38
086A:  MOVF   35,W
086B:  BTFSC  03.2
086C:  INCF   36,F
086D:  BSF    03.1
086E:  MOVLW  B1
086F:  MOVWF  04
0870:  BCF    03.7
0871:  MOVF   34,W
0872:  MOVWF  41
0873:  MOVF   33,W
0874:  MOVWF  40
0875:  MOVF   32,W
0876:  MOVWF  3F
0877:  MOVF   31,W
0878:  MOVWF  3E
0879:  MOVF   3D,W
087A:  MOVWF  45
087B:  MOVF   3C,W
087C:  MOVWF  44
087D:  MOVF   3B,W
087E:  MOVWF  43
087F:  MOVF   3A,W
0880:  MOVWF  42
0881:  BCF    0A.3
0882:  BCF    03.5
0883:  CALL   700
0884:  BSF    0A.3
0885:  MOVF   78,W
0886:  MOVF   77,F
0887:  BTFSS  03.2
0888:  GOTO   0A0
0889:  BSF    03.5
088A:  INCF   35,W
088B:  SUBWF  38,W
088C:  BTFSS  03.2
088D:  GOTO   090
088E:  BCF    03.5
088F:  GOTO   0A0
0890:  MOVF   36,W
0891:  BTFSC  03.2
0892:  GOTO   0A3
0893:  ANDLW  0F
0894:  SUBWF  38,W
0895:  BTFSC  03.2
0896:  GOTO   099
0897:  BTFSC  03.0
0898:  GOTO   0E3
0899:  BTFSC  36.7
089A:  GOTO   0E3
089B:  BTFSC  36.6
089C:  GOTO   0A3
089D:  MOVLW  20
089E:  GOTO   0DB
089F:  BCF    03.5
08A0:  MOVLW  20
08A1:  BSF    03.5
08A2:  ANDWF  36,F
08A3:  BTFSS  36.5
08A4:  GOTO   0B5
08A5:  BCF    36.5
08A6:  MOVF   35,W
08A7:  BTFSS  03.2
08A8:  DECF   36,F
08A9:  MOVF   77,W
08AA:  MOVWF  36
08AB:  MOVLW  2D
08AC:  MOVWF  3E
08AD:  BCF    0A.3
08AE:  BCF    03.5
08AF:  CALL   146
08B0:  BSF    0A.3
08B1:  BSF    03.5
08B2:  MOVF   36,W
08B3:  MOVWF  77
08B4:  CLRF   36
08B5:  MOVF   35,W
08B6:  SUBWF  38,W
08B7:  BTFSS  03.2
08B8:  GOTO   0C7
08B9:  MOVF   77,W
08BA:  MOVWF  36
08BB:  MOVLW  2E
08BC:  MOVWF  3E
08BD:  BCF    0A.3
08BE:  BCF    03.5
08BF:  CALL   146
08C0:  BSF    0A.3
08C1:  BSF    03.5
08C2:  MOVF   36,W
08C3:  MOVWF  77
08C4:  MOVLW  20
08C5:  ANDWF  36,F
08C6:  MOVLW  00
08C7:  MOVLW  30
08C8:  BTFSS  36.5
08C9:  GOTO   0DB
08CA:  BCF    36.5
08CB:  MOVF   35,W
08CC:  BTFSS  03.2
08CD:  DECF   36,F
08CE:  MOVF   77,W
08CF:  MOVWF  36
08D0:  MOVLW  2D
08D1:  MOVWF  3E
08D2:  BCF    0A.3
08D3:  BCF    03.5
08D4:  CALL   146
08D5:  BSF    0A.3
08D6:  BSF    03.5
08D7:  MOVF   36,W
08D8:  MOVWF  77
08D9:  CLRF   36
08DA:  MOVLW  30
08DB:  ADDWF  77,F
08DC:  MOVF   77,W
08DD:  MOVWF  3E
08DE:  BCF    0A.3
08DF:  BCF    03.5
08E0:  CALL   146
08E1:  BSF    0A.3
08E2:  BSF    03.5
08E3:  BCF    03.1
08E4:  MOVF   3D,W
08E5:  MOVWF  41
08E6:  MOVF   3C,W
08E7:  MOVWF  40
08E8:  MOVF   3B,W
08E9:  MOVWF  3F
08EA:  MOVF   3A,W
08EB:  MOVWF  3E
08EC:  CLRF   45
08ED:  CLRF   44
08EE:  CLRF   43
08EF:  MOVLW  0A
08F0:  MOVWF  42
08F1:  BCF    0A.3
08F2:  BCF    03.5
08F3:  CALL   700
08F4:  BSF    0A.3
08F5:  MOVF   7A,W
08F6:  BSF    03.5
08F7:  MOVWF  3D
08F8:  MOVF   79,W
08F9:  MOVWF  3C
08FA:  MOVF   78,W
08FB:  MOVWF  3B
08FC:  MOVF   77,W
08FD:  MOVWF  3A
08FE:  DECFSZ 38,F
08FF:  GOTO   06D
0900:  BCF    03.5
0901:  RETURN
*
0979:  BSF    0A.0
097A:  BCF    0A.1
097B:  BCF    0A.2
097C:  ADDWF  02,F
097D:  GOTO   110
097E:  GOTO   116
097F:  GOTO   11C
0980:  GOTO   122
*
0A52:  MOVF   3F,W
0A53:  XORWF  41,W
0A54:  ANDLW  80
0A55:  MOVWF  43
0A56:  BTFSS  3F.7
0A57:  GOTO   25D
0A58:  COMF   3E,F
0A59:  COMF   3F,F
0A5A:  INCF   3E,F
0A5B:  BTFSC  03.2
0A5C:  INCF   3F,F
0A5D:  BTFSS  41.7
0A5E:  GOTO   264
0A5F:  COMF   40,F
0A60:  COMF   41,F
0A61:  INCF   40,F
0A62:  BTFSC  03.2
0A63:  INCF   41,F
0A64:  MOVLW  10
0A65:  MOVWF  42
0A66:  CLRF   77
0A67:  CLRF   7A
0A68:  RRF    3F,F
0A69:  RRF    3E,F
0A6A:  BTFSS  03.0
0A6B:  GOTO   272
0A6C:  MOVF   40,W
0A6D:  ADDWF  77,F
0A6E:  BTFSC  03.0
0A6F:  INCF   7A,F
0A70:  MOVF   41,W
0A71:  ADDWF  7A,F
0A72:  RRF    7A,F
0A73:  RRF    77,F
0A74:  RRF    79,F
0A75:  RRF    78,F
0A76:  DECFSZ 42,F
0A77:  GOTO   268
0A78:  BTFSS  43.7
0A79:  GOTO   27F
0A7A:  COMF   78,F
0A7B:  COMF   79,F
0A7C:  INCF   78,F
0A7D:  BTFSC  03.2
0A7E:  INCF   79,F
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #USE DELAY(CLOCK=4000000) 
*
0074:  MOVLW  BF
0075:  MOVWF  04
0076:  BCF    03.7
0077:  MOVF   00,W
0078:  BTFSC  03.2
0079:  GOTO   088
007A:  MOVLW  01
007B:  MOVWF  78
007C:  CLRF   77
007D:  DECFSZ 77,F
007E:  GOTO   07D
007F:  DECFSZ 78,F
0080:  GOTO   07C
0081:  MOVLW  4A
0082:  MOVWF  77
0083:  DECFSZ 77,F
0084:  GOTO   083
0085:  GOTO   086
0086:  DECFSZ 00,F
0087:  GOTO   07A
0088:  RETURN
.................... #FUSES XT,NOPROTECT,NOWDT,NOBROWNOUT,PUT,NOLVP 
.................... #DEFINE USE_PORTB_KBD   //Por defecto el teclado se conecta al puerto D, 
....................                         //como el microcontrolador que se esta usando 
....................                         //no tiene puerto D se conecta al puerto B.*/ 
.................... #INCLUDE "LCD420D.C" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD420.C                               //// 
.................... ////            Driver for common 4x20 LCD modules                      //// 
.................... ////                                                                    //// 
.................... ////  lcd_init()   Must be called before any other function.            //// 
.................... ////                                                                    //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      //// 
.................... ////                     The following have special meaning:            //// 
.................... ////                      \f  Clear display                             //// 
.................... ////                      \n  Go to start of second line                //// 
.................... ////                      \b  Move back one position                    //// 
.................... ////                                                                    //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     //// 
.................... ////                                                                    //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD          //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     B0  enable 
.................... //     B1  rs 
.................... //     B2  rw 
.................... //     B4  D4 
.................... //     B5  D5 
.................... //     B6  D6 
.................... //     B7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used. 
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
.................... #byte lcd = 8                        // This puts the entire structure 
....................                                      // on to port B (at address 6) 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
.................... BYTE lcdline; 
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................  
....................       set_tris_d(LCD_READ); 
*
0098:  MOVLW  F0
0099:  BSF    03.5
009A:  MOVWF  08
....................       lcd.rw = 1; 
009B:  BCF    03.5
009C:  BSF    08.2
....................       delay_cycles(1); 
009D:  NOP
....................       lcd.enable = 1; 
009E:  BSF    08.0
....................       delay_cycles(1); 
009F:  NOP
....................       high = lcd.data; 
00A0:  MOVF   08,W
00A1:  SWAPF  08,W
00A2:  ANDLW  0F
00A3:  BSF    03.5
00A4:  MOVWF  45
....................       lcd.enable = 0; 
00A5:  BCF    03.5
00A6:  BCF    08.0
....................       delay_cycles(1); 
00A7:  NOP
....................       lcd.enable = 1; 
00A8:  BSF    08.0
....................       delay_us(1); 
00A9:  NOP
....................       low = lcd.data; 
00AA:  MOVF   08,W
00AB:  SWAPF  08,W
00AC:  ANDLW  0F
00AD:  BSF    03.5
00AE:  MOVWF  44
....................       lcd.enable = 0; 
00AF:  BCF    03.5
00B0:  BCF    08.0
....................       set_tris_d(LCD_WRITE); 
00B1:  MOVLW  00
00B2:  BSF    03.5
00B3:  MOVWF  08
....................       return( (high<<4) | low); 
00B4:  SWAPF  45,W
00B5:  MOVWF  77
00B6:  MOVLW  F0
00B7:  ANDWF  77,F
00B8:  MOVF   77,W
00B9:  IORWF  44,W
00BA:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0089:  BSF    03.5
008A:  SWAPF  45,W
008B:  ANDLW  F0
008C:  MOVWF  77
008D:  MOVLW  0F
008E:  BCF    03.5
008F:  ANDWF  08,W
0090:  IORWF  77,W
0091:  MOVWF  08
....................       delay_cycles(1); 
0092:  NOP
....................       lcd.enable = 1; 
0093:  BSF    08.0
....................       delay_us(2); 
0094:  GOTO   095
....................       lcd.enable = 0; 
0095:  BCF    08.0
0096:  RETURN
.................... } 
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
0097:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
00BB:  MOVF   78,W
00BC:  MOVWF  44
00BD:  BTFSS  44.7
00BE:  GOTO   0C1
00BF:  BCF    03.5
00C0:  GOTO   098
....................       lcd.rs = address; 
00C1:  BTFSC  42.0
00C2:  GOTO   0C6
00C3:  BCF    03.5
00C4:  BCF    08.1
00C5:  BSF    03.5
00C6:  BTFSS  42.0
00C7:  GOTO   0CB
00C8:  BCF    03.5
00C9:  BSF    08.1
00CA:  BSF    03.5
....................       delay_cycles(1); 
00CB:  NOP
....................       lcd.rw = 0; 
00CC:  BCF    03.5
00CD:  BCF    08.2
....................       delay_cycles(1); 
00CE:  NOP
....................       lcd.enable = 0; 
00CF:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
00D0:  BSF    03.5
00D1:  SWAPF  43,W
00D2:  MOVWF  44
00D3:  MOVLW  0F
00D4:  ANDWF  44,F
00D5:  MOVF   44,W
00D6:  MOVWF  45
00D7:  BCF    03.5
00D8:  CALL   089
....................       lcd_send_nibble(n & 0xf); 
00D9:  BSF    03.5
00DA:  MOVF   43,W
00DB:  ANDLW  0F
00DC:  MOVWF  44
00DD:  MOVWF  45
00DE:  BCF    03.5
00DF:  CALL   089
00E0:  RETURN
.................... } 
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................  
....................     set_tris_d(LCD_WRITE); 
00E1:  MOVLW  00
00E2:  BSF    03.5
00E3:  MOVWF  08
....................     lcd.rs = 0; 
00E4:  BCF    03.5
00E5:  BCF    08.1
....................     lcd.rw = 0; 
00E6:  BCF    08.2
....................     lcd.enable = 0; 
00E7:  BCF    08.0
....................     delay_ms(15); 
00E8:  MOVLW  0F
00E9:  BSF    03.5
00EA:  MOVWF  3F
00EB:  BCF    03.5
00EC:  CALL   074
....................     for(i=1;i<=3;++i) { 
00ED:  MOVLW  01
00EE:  BSF    03.5
00EF:  MOVWF  2D
00F0:  MOVF   2D,W
00F1:  SUBLW  03
00F2:  BTFSS  03.0
00F3:  GOTO   100
....................        lcd_send_nibble(3); 
00F4:  MOVLW  03
00F5:  MOVWF  45
00F6:  BCF    03.5
00F7:  CALL   089
....................        delay_ms(5); 
00F8:  MOVLW  05
00F9:  BSF    03.5
00FA:  MOVWF  3F
00FB:  BCF    03.5
00FC:  CALL   074
00FD:  BSF    03.5
00FE:  INCF   2D,F
00FF:  GOTO   0F0
....................     } 
....................     lcd_send_nibble(2); 
0100:  MOVLW  02
0101:  MOVWF  45
0102:  BCF    03.5
0103:  CALL   089
....................     for(i=0;i<=3;++i) 
0104:  BSF    03.5
0105:  CLRF   2D
0106:  MOVF   2D,W
0107:  SUBLW  03
0108:  BTFSS  03.0
0109:  GOTO   117
....................        lcd_send_byte(0, LCD_INIT_STRING[i]); 
010A:  MOVF   2D,W
010B:  BCF    03.5
010C:  CALL   004
010D:  BSF    03.5
010E:  MOVWF  2E
010F:  CLRF   42
0110:  MOVF   2E,W
0111:  MOVWF  43
0112:  BCF    03.5
0113:  CALL   097
0114:  BSF    03.5
0115:  INCF   2D,F
0116:  GOTO   106
0117:  BCF    03.5
0118:  BCF    0A.3
0119:  BSF    0A.4
011A:  GOTO   093 (RETURN)
.................... } 
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    switch(y) { 
011B:  MOVLW  01
011C:  BSF    03.5
011D:  SUBWF  40,W
011E:  ADDLW  FC
011F:  BTFSC  03.0
0120:  GOTO   135
0121:  ADDLW  04
0122:  BCF    03.5
0123:  GOTO   13E
....................      case 1 : address=0x80;break; 
0124:  MOVLW  80
0125:  BSF    03.5
0126:  MOVWF  41
0127:  GOTO   135
....................      case 2 : address=0xc0;break; 
0128:  MOVLW  C0
0129:  BSF    03.5
012A:  MOVWF  41
012B:  GOTO   135
....................      case 3 : address=0x94;break; 
012C:  MOVLW  94
012D:  BSF    03.5
012E:  MOVWF  41
012F:  GOTO   135
....................      case 4 : address=0xd4;break; 
0130:  MOVLW  D4
0131:  BSF    03.5
0132:  MOVWF  41
0133:  GOTO   135
0134:  BSF    03.5
....................    } 
....................    address+=x-1; 
0135:  MOVLW  01
0136:  SUBWF  3F,W
0137:  ADDWF  41,F
....................    lcd_send_byte(0,address); 
0138:  CLRF   42
0139:  MOVF   41,W
013A:  MOVWF  43
013B:  BCF    03.5
013C:  CALL   097
013D:  RETURN
.................... } 
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
0146:  BSF    03.5
0147:  MOVF   3E,W
0148:  XORLW  0C
0149:  BCF    03.5
014A:  BTFSC  03.2
014B:  GOTO   153
014C:  XORLW  06
014D:  BTFSC  03.2
014E:  GOTO   161
014F:  XORLW  02
0150:  BTFSC  03.2
0151:  GOTO   16C
0152:  GOTO   173
....................      case '\f'   : lcd_send_byte(0,1); 
0153:  BSF    03.5
0154:  CLRF   42
0155:  MOVLW  01
0156:  MOVWF  43
0157:  BCF    03.5
0158:  CALL   097
....................                    lcdline=1; 
0159:  MOVLW  01
015A:  MOVWF  20
....................                    delay_ms(2); 
015B:  MOVLW  02
015C:  BSF    03.5
015D:  MOVWF  3F
015E:  BCF    03.5
015F:  CALL   074
....................                                            break; 
0160:  GOTO   17A
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break; 
0161:  INCF   20,F
0162:  MOVLW  01
0163:  BSF    03.5
0164:  MOVWF  3F
0165:  BCF    03.5
0166:  MOVF   20,W
0167:  BSF    03.5
0168:  MOVWF  40
0169:  BCF    03.5
016A:  CALL   11B
016B:  GOTO   17A
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
016C:  BSF    03.5
016D:  CLRF   42
016E:  MOVLW  10
016F:  MOVWF  43
0170:  BCF    03.5
0171:  CALL   097
0172:  GOTO   17A
....................      default     : lcd_send_byte(1,c);     break; 
0173:  MOVLW  01
0174:  BSF    03.5
0175:  MOVWF  42
0176:  MOVF   3E,W
0177:  MOVWF  43
0178:  BCF    03.5
0179:  CALL   097
....................    } 
017A:  RETURN
.................... } 
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
....................  
.................... #INCLUDE <KBD4x4.C>  //Incluir en el encabezado el driver para 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBD4x4_1.C                                //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 4) 
.................... #define COL1 (1 << 5) 
.................... #define COL2 (1 << 6) 
.................... #define COL3 (1 << 7) 
....................  
.................... #define ROW0 (1 << 0) 
.................... #define ROW1 (1 << 1) 
.................... #define ROW2 (1 << 2) 
.................... #define ROW3 (1 << 3) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][4] = {{'1','2','3','A'}, 
....................                          {'4','5','6','B'}, 
....................                          {'7','8','9','C'}, 
....................                          {'*','0','#','D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
1054:  BCF    03.6
1055:  CLRF   21
....................    static int1 kbd_down; 
1056:  BCF    22.0
....................    static char last_key; 
1057:  CLRF   23
....................    static BYTE col; 
1058:  CLRF   24
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
0902:  BSF    03.5
0903:  CLRF   37
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
0904:  BCF    03.5
0905:  INCF   21,F
0906:  MOVF   21,W
0907:  SUBLW  21
0908:  BTFSC  03.0
0909:  GOTO   172
....................        switch (col) { 
090A:  MOVF   24,W
090B:  ADDLW  FC
090C:  BTFSC  03.0
090D:  GOTO   127
090E:  ADDLW  04
090F:  GOTO   179
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
0910:  MOVLW  EF
0911:  BSF    03.5
0912:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
0913:  BCF    03.5
0914:  MOVWF  06
....................                     break; 
0915:  GOTO   127
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
0916:  MOVLW  DF
0917:  BSF    03.5
0918:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
0919:  BCF    03.5
091A:  MOVWF  06
....................                     break; 
091B:  GOTO   127
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
091C:  MOVLW  BF
091D:  BSF    03.5
091E:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
091F:  BCF    03.5
0920:  MOVWF  06
....................                     break; 
0921:  GOTO   127
....................          case 3   : set_tris_kbd(ALL_PINS&~COL3); 
0922:  MOVLW  7F
0923:  BSF    03.5
0924:  MOVWF  06
....................                     kbd=~COL3&ALL_PINS; 
0925:  BCF    03.5
0926:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
0927:  BTFSS  22.0
0928:  GOTO   135
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
0929:  MOVF   06,W
092A:  ANDLW  0F
092B:  SUBLW  0F
092C:  BTFSS  03.2
092D:  GOTO   134
....................            kbd_down=FALSE; 
092E:  BCF    22.0
....................            kchar=last_key; 
092F:  MOVF   23,W
0930:  BSF    03.5
0931:  MOVWF  37
....................            last_key='\0'; 
0932:  BCF    03.5
0933:  CLRF   23
....................          } 
....................        } else { 
0934:  GOTO   171
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
0935:  MOVF   06,W
0936:  ANDLW  0F
0937:  SUBLW  0F
0938:  BTFSC  03.2
0939:  GOTO   16C
....................              if((kbd & ROW0)==0) 
093A:  MOVF   06,W
093B:  ANDLW  01
093C:  BTFSS  03.2
093D:  GOTO   142
....................                row=0; 
093E:  BSF    03.5
093F:  CLRF   38
0940:  GOTO   15B
0941:  BCF    03.5
....................              else if((kbd & ROW1)==0) 
0942:  MOVF   06,W
0943:  ANDLW  02
0944:  BTFSS  03.2
0945:  GOTO   14B
....................                row=1; 
0946:  MOVLW  01
0947:  BSF    03.5
0948:  MOVWF  38
0949:  GOTO   15B
094A:  BCF    03.5
....................              else if((kbd & ROW2)==0) 
094B:  MOVF   06,W
094C:  ANDLW  04
094D:  BTFSS  03.2
094E:  GOTO   154
....................                row=2; 
094F:  MOVLW  02
0950:  BSF    03.5
0951:  MOVWF  38
0952:  GOTO   15B
0953:  BCF    03.5
....................              else if((kbd & ROW3)==0) 
0954:  MOVF   06,W
0955:  ANDLW  08
0956:  BTFSS  03.2
0957:  GOTO   15C
....................                row=3; 
0958:  MOVLW  03
0959:  BSF    03.5
095A:  MOVWF  38
095B:  BCF    03.5
....................              last_key =KEYS[row][col]; 
095C:  BSF    03.5
095D:  RLF    38,W
095E:  MOVWF  77
095F:  RLF    77,F
0960:  MOVLW  FC
0961:  ANDWF  77,F
0962:  MOVF   77,W
0963:  BCF    03.5
0964:  ADDWF  24,W
0965:  BCF    0A.3
0966:  CALL   00C
0967:  BSF    0A.3
0968:  MOVWF  78
0969:  MOVWF  23
....................              kbd_down = TRUE; 
096A:  BSF    22.0
....................           } else { 
096B:  GOTO   171
....................              ++col; 
096C:  INCF   24,F
....................              if(col==4) 
096D:  MOVF   24,W
096E:  SUBLW  04
096F:  BTFSC  03.2
....................                col=0; 
0970:  CLRF   24
....................           } 
....................        } 
....................       kbd_call_count=0; 
0971:  CLRF   21
....................    } 
....................   set_tris_kbd(ALL_PINS); 
0972:  MOVLW  FF
0973:  BSF    03.5
0974:  MOVWF  06
....................   return(kchar); 
0975:  MOVF   37,W
0976:  MOVWF  78
0977:  BCF    03.5
0978:  RETURN
.................... } 
....................  
....................                       //manejar el teclado telefnico MODIFICADO 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
1059:  CLRF   25
105A:  CLRF   26
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
09DF:  CLRF   3C
....................    sign = 0; 
09E0:  CLRF   3A
....................    base = 10; 
09E1:  MOVLW  0A
09E2:  MOVWF  3B
....................    result = 0; 
09E3:  CLRF   39
09E4:  CLRF   38
....................  
....................    if (!s) 
09E5:  MOVF   36,W
09E6:  IORWF  37,W
09E7:  BTFSS  03.2
09E8:  GOTO   1ED
....................       return 0; 
09E9:  MOVLW  00
09EA:  MOVWF  78
09EB:  MOVWF  79
09EC:  GOTO   316
....................    c = s[index++]; 
09ED:  MOVF   3C,W
09EE:  INCF   3C,F
09EF:  ADDWF  36,W
09F0:  MOVWF  04
09F1:  BCF    03.7
09F2:  BTFSC  37.0
09F3:  BSF    03.7
09F4:  MOVF   00,W
09F5:  MOVWF  3D
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
09F6:  MOVF   3D,W
09F7:  SUBLW  2D
09F8:  BTFSS  03.2
09F9:  GOTO   206
....................    { 
....................       sign = 1;         // Set the sign to negative 
09FA:  MOVLW  01
09FB:  MOVWF  3A
....................       c = s[index++]; 
09FC:  MOVF   3C,W
09FD:  INCF   3C,F
09FE:  ADDWF  36,W
09FF:  MOVWF  04
0A00:  BCF    03.7
0A01:  BTFSC  37.0
0A02:  BSF    03.7
0A03:  MOVF   00,W
0A04:  MOVWF  3D
....................    } 
0A05:  GOTO   213
....................    else if (c == '+') 
0A06:  MOVF   3D,W
0A07:  SUBLW  2B
0A08:  BTFSS  03.2
0A09:  GOTO   213
....................    { 
....................       c = s[index++]; 
0A0A:  MOVF   3C,W
0A0B:  INCF   3C,F
0A0C:  ADDWF  36,W
0A0D:  MOVWF  04
0A0E:  BCF    03.7
0A0F:  BTFSC  37.0
0A10:  BSF    03.7
0A11:  MOVF   00,W
0A12:  MOVWF  3D
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A13:  MOVF   3D,W
0A14:  SUBLW  2F
0A15:  BTFSC  03.0
0A16:  GOTO   307
0A17:  MOVF   3D,W
0A18:  SUBLW  39
0A19:  BTFSS  03.0
0A1A:  GOTO   307
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A1B:  MOVF   3D,W
0A1C:  SUBLW  30
0A1D:  BTFSS  03.2
0A1E:  GOTO   23F
0A1F:  MOVF   3C,W
0A20:  ADDWF  36,W
0A21:  MOVWF  04
0A22:  BCF    03.7
0A23:  BTFSC  37.0
0A24:  BSF    03.7
0A25:  MOVF   00,W
0A26:  SUBLW  78
0A27:  BTFSC  03.2
0A28:  GOTO   233
0A29:  MOVF   3C,W
0A2A:  ADDWF  36,W
0A2B:  MOVWF  04
0A2C:  BCF    03.7
0A2D:  BTFSC  37.0
0A2E:  BSF    03.7
0A2F:  MOVF   00,W
0A30:  SUBLW  58
0A31:  BTFSS  03.2
0A32:  GOTO   23F
....................       { 
....................          base = 16; 
0A33:  MOVLW  10
0A34:  MOVWF  3B
....................          index++; 
0A35:  INCF   3C,F
....................          c = s[index++]; 
0A36:  MOVF   3C,W
0A37:  INCF   3C,F
0A38:  ADDWF  36,W
0A39:  MOVWF  04
0A3A:  BCF    03.7
0A3B:  BTFSC  37.0
0A3C:  BSF    03.7
0A3D:  MOVF   00,W
0A3E:  MOVWF  3D
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0A3F:  MOVF   3B,W
0A40:  SUBLW  0A
0A41:  BTFSS  03.2
0A42:  GOTO   296
....................       { 
....................          while (c >= '0' && c <= '9') 
0A43:  MOVF   3D,W
0A44:  SUBLW  2F
0A45:  BTFSC  03.0
0A46:  GOTO   295
0A47:  MOVF   3D,W
0A48:  SUBLW  39
0A49:  BTFSS  03.0
0A4A:  GOTO   295
....................          { 
....................             result = 10*result + (c - '0'); 
0A4B:  CLRF   3F
0A4C:  MOVLW  0A
0A4D:  MOVWF  3E
0A4E:  MOVF   39,W
0A4F:  MOVWF  41
0A50:  MOVF   38,W
0A51:  MOVWF  40
*
0A7F:  MOVF   79,W
0A80:  MOVWF  3F
0A81:  MOVF   78,W
0A82:  MOVWF  3E
0A83:  MOVLW  30
0A84:  SUBWF  3D,W
0A85:  ADDWF  3E,W
0A86:  MOVWF  38
0A87:  MOVF   3F,W
0A88:  MOVWF  39
0A89:  BTFSC  03.0
0A8A:  INCF   39,F
....................             c = s[index++]; 
0A8B:  MOVF   3C,W
0A8C:  INCF   3C,F
0A8D:  ADDWF  36,W
0A8E:  MOVWF  04
0A8F:  BCF    03.7
0A90:  BTFSC  37.0
0A91:  BSF    03.7
0A92:  MOVF   00,W
0A93:  MOVWF  3D
0A94:  GOTO   243
....................          } 
....................       } 
0A95:  GOTO   307
....................       else if (base == 16)    // The number is a hexa number 
0A96:  MOVF   3B,W
0A97:  SUBLW  10
0A98:  BTFSS  03.2
0A99:  GOTO   307
....................       { 
....................          c = toupper(c); 
0A9A:  MOVF   3D,W
0A9B:  SUBLW  60
0A9C:  BTFSC  03.0
0A9D:  GOTO   2A5
0A9E:  MOVF   3D,W
0A9F:  SUBLW  7A
0AA0:  BTFSS  03.0
0AA1:  GOTO   2A5
0AA2:  MOVF   3D,W
0AA3:  ANDLW  DF
0AA4:  GOTO   2A6
0AA5:  MOVF   3D,W
0AA6:  MOVWF  3D
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0AA7:  MOVF   3D,W
0AA8:  SUBLW  2F
0AA9:  BTFSC  03.0
0AAA:  GOTO   2AF
0AAB:  MOVF   3D,W
0AAC:  SUBLW  39
0AAD:  BTFSC  03.0
0AAE:  GOTO   2B7
0AAF:  MOVF   3D,W
0AB0:  SUBLW  40
0AB1:  BTFSC  03.0
0AB2:  GOTO   307
0AB3:  MOVF   3D,W
0AB4:  SUBLW  46
0AB5:  BTFSS  03.0
0AB6:  GOTO   307
....................          { 
....................             if (c >= '0' && c <= '9') 
0AB7:  MOVF   3D,W
0AB8:  SUBLW  2F
0AB9:  BTFSC  03.0
0ABA:  GOTO   2D8
0ABB:  MOVF   3D,W
0ABC:  SUBLW  39
0ABD:  BTFSS  03.0
0ABE:  GOTO   2D8
....................                result = (result << 4) + (c - '0'); 
0ABF:  RLF    38,W
0AC0:  MOVWF  3E
0AC1:  RLF    39,W
0AC2:  MOVWF  3F
0AC3:  RLF    3E,F
0AC4:  RLF    3F,F
0AC5:  RLF    3E,F
0AC6:  RLF    3F,F
0AC7:  RLF    3E,F
0AC8:  RLF    3F,F
0AC9:  MOVLW  F0
0ACA:  ANDWF  3E,F
0ACB:  MOVLW  30
0ACC:  SUBWF  3D,W
0ACD:  ADDWF  3E,W
0ACE:  MOVWF  78
0ACF:  MOVF   3F,W
0AD0:  MOVWF  7A
0AD1:  BTFSC  03.0
0AD2:  INCF   7A,F
0AD3:  MOVF   78,W
0AD4:  MOVWF  38
0AD5:  MOVF   7A,W
0AD6:  MOVWF  39
0AD7:  GOTO   2F1
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0AD8:  RLF    38,W
0AD9:  MOVWF  3E
0ADA:  RLF    39,W
0ADB:  MOVWF  3F
0ADC:  RLF    3E,F
0ADD:  RLF    3F,F
0ADE:  RLF    3E,F
0ADF:  RLF    3F,F
0AE0:  RLF    3E,F
0AE1:  RLF    3F,F
0AE2:  MOVLW  F0
0AE3:  ANDWF  3E,F
0AE4:  MOVLW  41
0AE5:  SUBWF  3D,W
0AE6:  ADDLW  0A
0AE7:  ADDWF  3E,W
0AE8:  MOVWF  78
0AE9:  MOVF   3F,W
0AEA:  MOVWF  7A
0AEB:  BTFSC  03.0
0AEC:  INCF   7A,F
0AED:  MOVF   78,W
0AEE:  MOVWF  38
0AEF:  MOVF   7A,W
0AF0:  MOVWF  39
....................  
....................             c = s[index++];c = toupper(c); 
0AF1:  MOVF   3C,W
0AF2:  INCF   3C,F
0AF3:  ADDWF  36,W
0AF4:  MOVWF  04
0AF5:  BCF    03.7
0AF6:  BTFSC  37.0
0AF7:  BSF    03.7
0AF8:  MOVF   00,W
0AF9:  MOVWF  3D
0AFA:  SUBLW  60
0AFB:  BTFSC  03.0
0AFC:  GOTO   304
0AFD:  MOVF   3D,W
0AFE:  SUBLW  7A
0AFF:  BTFSS  03.0
0B00:  GOTO   304
0B01:  MOVF   3D,W
0B02:  ANDLW  DF
0B03:  GOTO   305
0B04:  MOVF   3D,W
0B05:  MOVWF  3D
0B06:  GOTO   2A7
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0B07:  MOVF   3B,W
0B08:  SUBLW  0A
0B09:  BTFSS  03.2
0B0A:  GOTO   312
0B0B:  DECFSZ 3A,W
0B0C:  GOTO   312
....................       result = -result; 
0B0D:  COMF   38,F
0B0E:  COMF   39,F
0B0F:  INCF   38,F
0B10:  BTFSC  03.2
0B11:  INCF   39,F
....................  
....................    return(result); 
0B12:  MOVF   38,W
0B13:  MOVWF  78
0B14:  MOVF   39,W
0B15:  MOVWF  79
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use     standard_io(b)  
.................... #define  KEYHIT_DELAY   1    //Tiempo de espera del teclado en milisegundos 
.................... #byte PORTB= 6 
.................... #byte PORTC= 7 
.................... #BYTE PORTA= 5 
.................... #BYTE PORTD= 8 
....................  
.................... int16 adc,control=0; 
.................... float R=1500;//Referencia de 150 C por defecto 
.................... float yM=0,e=0.0,e_1=0.0,e_2=0.0,u=0.0,u_1=0.0,T=0.1; 
.................... float kp,ti,td,q0,q1,q2; 
.................... float k=0.535,tao=10,theta=1; 
.................... float TsMA,Wn,P1,P2; 
.................... char c; 
.................... int cont=0; 
....................  
....................  
.................... /*===========================================================================*/ 
.................... /*=======================       FUNCION TECLA         =======================*/ 
.................... /*===========================================================================*/ 
.................... //Funcion encargada de esperar a que se presione una tecla  
.................... char tecla(void) 
.................... { 
....................    char c; 
....................    do{ //espera hasta que se presione una tecla 
....................       c=kbd_getc(); //Captura valor del teclado 
*
09AF:  BCF    03.5
09B0:  CALL   102
09B1:  MOVF   78,W
09B2:  BSF    03.5
09B3:  MOVWF  36
....................      } 
....................    while(c=='\0');  
09B4:  MOVF   36,F
09B5:  BTFSC  03.2
09B6:  GOTO   1AF
....................    return(c); 
09B7:  MOVF   36,W
09B8:  MOVWF  78
.................... } 
....................  
.................... /*===========================================================================*/ 
.................... /*=======================    FUNCION TECLA CON TIMER  =======================*/ 
.................... /*===========================================================================*/ 
.................... // Pregunta por una Tecla por un tiempo, si no hay actividad, deja de preguntar 
.................... // y deja que el PIC continue con su trabajo 
....................  
.................... char tecla_time(void) { 
*
0981:  BSF    03.5
0982:  CLRF   2D
....................    char c='\0'; 
....................    unsigned int16 timeout; 
....................    timeout=0; 
0983:  CLRF   2F
0984:  CLRF   2E
....................    c=kbd_getc(); //Captura valor del teclado 
0985:  BCF    03.5
0986:  CALL   102
0987:  MOVF   78,W
0988:  BSF    03.5
0989:  MOVWF  2D
....................    while(c=='\0' && (++timeout< (KEYHIT_DELAY*100))) 
098A:  MOVF   2D,F
098B:  BTFSS  03.2
098C:  GOTO   1A1
098D:  INCF   2E,F
098E:  BTFSC  03.2
098F:  INCF   2F,F
0990:  MOVF   2F,F
0991:  BTFSS  03.2
0992:  GOTO   1A1
0993:  MOVF   2E,W
0994:  SUBLW  63
0995:  BTFSS  03.0
0996:  GOTO   1A1
....................    { 
....................       delay_us(10); 
0997:  MOVLW  03
0998:  MOVWF  77
0999:  DECFSZ 77,F
099A:  GOTO   199
....................       c=kbd_getc(); //Captura valor del teclado 
099B:  BCF    03.5
099C:  CALL   102
099D:  MOVF   78,W
099E:  BSF    03.5
099F:  MOVWF  2D
09A0:  GOTO   18A
....................    } 
....................    return(c); 
09A1:  MOVF   2D,W
09A2:  MOVWF  78
09A3:  BCF    03.5
09A4:  BCF    0A.3
09A5:  BSF    0A.4
09A6:  GOTO   4E8 (RETURN)
.................... } 
....................  
....................  
.................... /*===========================================================================*/ 
.................... /*=======================    FUNCION DEL CONTROL PID  =======================*/ 
.................... /*===========================================================================*/ 
.................... void PID(void) 
.................... { 
....................      
....................     e=1*(R-yM); 
*
04D8:  BSF    03.1
04D9:  MOVF   32,W
04DA:  BSF    03.5
04DB:  MOVWF  38
04DC:  BCF    03.5
04DD:  MOVF   31,W
04DE:  BSF    03.5
04DF:  MOVWF  37
04E0:  BCF    03.5
04E1:  MOVF   30,W
04E2:  BSF    03.5
04E3:  MOVWF  36
04E4:  BCF    03.5
04E5:  MOVF   2F,W
04E6:  BSF    03.5
04E7:  MOVWF  35
04E8:  BCF    03.5
04E9:  MOVF   36,W
04EA:  BSF    03.5
04EB:  MOVWF  3C
04EC:  BCF    03.5
04ED:  MOVF   35,W
04EE:  BSF    03.5
04EF:  MOVWF  3B
04F0:  BCF    03.5
04F1:  MOVF   34,W
04F2:  BSF    03.5
04F3:  MOVWF  3A
04F4:  BCF    03.5
04F5:  MOVF   33,W
04F6:  BSF    03.5
04F7:  MOVWF  39
04F8:  BCF    03.5
04F9:  CALL   332
04FA:  BSF    03.5
04FB:  CLRF   41
04FC:  CLRF   40
04FD:  CLRF   3F
04FE:  MOVLW  7F
04FF:  MOVWF  3E
0500:  MOVF   7A,W
0501:  MOVWF  45
0502:  MOVF   79,W
0503:  MOVWF  44
0504:  MOVF   78,W
0505:  MOVWF  43
0506:  MOVF   77,W
0507:  MOVWF  42
0508:  BCF    03.5
0509:  CALL   2BB
050A:  MOVF   7A,W
050B:  MOVWF  3A
050C:  MOVF   79,W
050D:  MOVWF  39
050E:  MOVF   78,W
050F:  MOVWF  38
0510:  MOVF   77,W
0511:  MOVWF  37
....................     // Controle PID 
....................       u = u_1 + q0*e + q1*e_1 + q2*e_2; //Ley del controlador PID discreto 
0512:  MOVF   5E,W
0513:  BSF    03.5
0514:  MOVWF  41
0515:  BCF    03.5
0516:  MOVF   5D,W
0517:  BSF    03.5
0518:  MOVWF  40
0519:  BCF    03.5
051A:  MOVF   5C,W
051B:  BSF    03.5
051C:  MOVWF  3F
051D:  BCF    03.5
051E:  MOVF   5B,W
051F:  BSF    03.5
0520:  MOVWF  3E
0521:  BCF    03.5
0522:  MOVF   3A,W
0523:  BSF    03.5
0524:  MOVWF  45
0525:  BCF    03.5
0526:  MOVF   39,W
0527:  BSF    03.5
0528:  MOVWF  44
0529:  BCF    03.5
052A:  MOVF   38,W
052B:  BSF    03.5
052C:  MOVWF  43
052D:  BCF    03.5
052E:  MOVF   37,W
052F:  BSF    03.5
0530:  MOVWF  42
0531:  BCF    03.5
0532:  CALL   2BB
0533:  BCF    03.1
0534:  MOVF   4A,W
0535:  BSF    03.5
0536:  MOVWF  38
0537:  BCF    03.5
0538:  MOVF   49,W
0539:  BSF    03.5
053A:  MOVWF  37
053B:  BCF    03.5
053C:  MOVF   48,W
053D:  BSF    03.5
053E:  MOVWF  36
053F:  BCF    03.5
0540:  MOVF   47,W
0541:  BSF    03.5
0542:  MOVWF  35
0543:  MOVF   7A,W
0544:  MOVWF  3C
0545:  MOVF   79,W
0546:  MOVWF  3B
0547:  MOVF   78,W
0548:  MOVWF  3A
0549:  MOVF   77,W
054A:  MOVWF  39
054B:  BCF    03.5
054C:  CALL   332
054D:  MOVF   7A,W
054E:  BSF    03.5
054F:  MOVWF  30
0550:  MOVF   79,W
0551:  MOVWF  2F
0552:  MOVF   78,W
0553:  MOVWF  2E
0554:  MOVF   77,W
0555:  MOVWF  2D
0556:  BCF    03.5
0557:  MOVF   62,W
0558:  BSF    03.5
0559:  MOVWF  41
055A:  BCF    03.5
055B:  MOVF   61,W
055C:  BSF    03.5
055D:  MOVWF  40
055E:  BCF    03.5
055F:  MOVF   60,W
0560:  BSF    03.5
0561:  MOVWF  3F
0562:  BCF    03.5
0563:  MOVF   5F,W
0564:  BSF    03.5
0565:  MOVWF  3E
0566:  BCF    03.5
0567:  MOVF   3E,W
0568:  BSF    03.5
0569:  MOVWF  45
056A:  BCF    03.5
056B:  MOVF   3D,W
056C:  BSF    03.5
056D:  MOVWF  44
056E:  BCF    03.5
056F:  MOVF   3C,W
0570:  BSF    03.5
0571:  MOVWF  43
0572:  BCF    03.5
0573:  MOVF   3B,W
0574:  BSF    03.5
0575:  MOVWF  42
0576:  BCF    03.5
0577:  CALL   2BB
0578:  BCF    03.1
0579:  BSF    03.5
057A:  MOVF   30,W
057B:  MOVWF  38
057C:  MOVF   2F,W
057D:  MOVWF  37
057E:  MOVF   2E,W
057F:  MOVWF  36
0580:  MOVF   2D,W
0581:  MOVWF  35
0582:  MOVF   7A,W
0583:  MOVWF  3C
0584:  MOVF   79,W
0585:  MOVWF  3B
0586:  MOVF   78,W
0587:  MOVWF  3A
0588:  MOVF   77,W
0589:  MOVWF  39
058A:  BCF    03.5
058B:  CALL   332
058C:  MOVF   7A,W
058D:  BSF    03.5
058E:  MOVWF  30
058F:  MOVF   79,W
0590:  MOVWF  2F
0591:  MOVF   78,W
0592:  MOVWF  2E
0593:  MOVF   77,W
0594:  MOVWF  2D
0595:  BCF    03.5
0596:  MOVF   66,W
0597:  BSF    03.5
0598:  MOVWF  41
0599:  BCF    03.5
059A:  MOVF   65,W
059B:  BSF    03.5
059C:  MOVWF  40
059D:  BCF    03.5
059E:  MOVF   64,W
059F:  BSF    03.5
05A0:  MOVWF  3F
05A1:  BCF    03.5
05A2:  MOVF   63,W
05A3:  BSF    03.5
05A4:  MOVWF  3E
05A5:  BCF    03.5
05A6:  MOVF   42,W
05A7:  BSF    03.5
05A8:  MOVWF  45
05A9:  BCF    03.5
05AA:  MOVF   41,W
05AB:  BSF    03.5
05AC:  MOVWF  44
05AD:  BCF    03.5
05AE:  MOVF   40,W
05AF:  BSF    03.5
05B0:  MOVWF  43
05B1:  BCF    03.5
05B2:  MOVF   3F,W
05B3:  BSF    03.5
05B4:  MOVWF  42
05B5:  BCF    03.5
05B6:  CALL   2BB
05B7:  BCF    03.1
05B8:  BSF    03.5
05B9:  MOVF   30,W
05BA:  MOVWF  38
05BB:  MOVF   2F,W
05BC:  MOVWF  37
05BD:  MOVF   2E,W
05BE:  MOVWF  36
05BF:  MOVF   2D,W
05C0:  MOVWF  35
05C1:  MOVF   7A,W
05C2:  MOVWF  3C
05C3:  MOVF   79,W
05C4:  MOVWF  3B
05C5:  MOVF   78,W
05C6:  MOVWF  3A
05C7:  MOVF   77,W
05C8:  MOVWF  39
05C9:  BCF    03.5
05CA:  CALL   332
05CB:  MOVF   7A,W
05CC:  MOVWF  46
05CD:  MOVF   79,W
05CE:  MOVWF  45
05CF:  MOVF   78,W
05D0:  MOVWF  44
05D1:  MOVF   77,W
05D2:  MOVWF  43
....................      
....................     if (u >= 5000.0)        //Saturo la accion de control 'uT' en un tope maximo y minimo 
05D3:  BSF    03.5
05D4:  CLRF   30
05D5:  MOVLW  40
05D6:  MOVWF  2F
05D7:  MOVLW  1C
05D8:  MOVWF  2E
05D9:  MOVLW  8B
05DA:  MOVWF  2D
05DB:  BCF    03.5
05DC:  MOVF   46,W
05DD:  BSF    03.5
05DE:  MOVWF  34
05DF:  BCF    03.5
05E0:  MOVF   45,W
05E1:  BSF    03.5
05E2:  MOVWF  33
05E3:  BCF    03.5
05E4:  MOVF   44,W
05E5:  BSF    03.5
05E6:  MOVWF  32
05E7:  BCF    03.5
05E8:  MOVF   43,W
05E9:  BSF    03.5
05EA:  MOVWF  31
05EB:  BCF    03.5
05EC:  CALL   497
05ED:  BTFSC  03.0
05EE:  GOTO   5F1
05EF:  BTFSS  03.2
05F0:  GOTO   5F8
....................      u = 5000.0; 
05F1:  CLRF   46
05F2:  MOVLW  40
05F3:  MOVWF  45
05F4:  MOVLW  1C
05F5:  MOVWF  44
05F6:  MOVLW  8B
05F7:  MOVWF  43
....................      
....................     if (u <= 0.0) 
05F8:  MOVF   46,W
05F9:  BSF    03.5
05FA:  MOVWF  30
05FB:  BCF    03.5
05FC:  MOVF   45,W
05FD:  BSF    03.5
05FE:  MOVWF  2F
05FF:  BCF    03.5
0600:  MOVF   44,W
0601:  BSF    03.5
0602:  MOVWF  2E
0603:  BCF    03.5
0604:  MOVF   43,W
0605:  BSF    03.5
0606:  MOVWF  2D
0607:  CLRF   34
0608:  CLRF   33
0609:  CLRF   32
060A:  CLRF   31
060B:  BCF    03.5
060C:  CALL   497
060D:  BTFSC  03.0
060E:  GOTO   611
060F:  BTFSS  03.2
0610:  GOTO   615
....................      u = 0.0; 
0611:  CLRF   46
0612:  CLRF   45
0613:  CLRF   44
0614:  CLRF   43
....................       
....................      control=u/5; 
0615:  MOVF   46,W
0616:  BSF    03.5
0617:  MOVWF  3C
0618:  BCF    03.5
0619:  MOVF   45,W
061A:  BSF    03.5
061B:  MOVWF  3B
061C:  BCF    03.5
061D:  MOVF   44,W
061E:  BSF    03.5
061F:  MOVWF  3A
0620:  BCF    03.5
0621:  MOVF   43,W
0622:  BSF    03.5
0623:  MOVWF  39
0624:  CLRF   40
0625:  CLRF   3F
0626:  MOVLW  20
0627:  MOVWF  3E
0628:  MOVLW  81
0629:  MOVWF  3D
062A:  BCF    03.5
062B:  CALL   1EF
062C:  MOVF   7A,W
062D:  BSF    03.5
062E:  MOVWF  30
062F:  MOVF   79,W
0630:  MOVWF  2F
0631:  MOVF   78,W
0632:  MOVWF  2E
0633:  MOVF   77,W
0634:  MOVWF  2D
*
0653:  MOVF   79,W
0654:  BCF    03.5
0655:  MOVWF  2E
0656:  MOVF   78,W
0657:  MOVWF  2D
....................       
....................      //Retorno a los valores reales 
....................      e_2=e_1; 
0658:  MOVF   3E,W
0659:  MOVWF  42
065A:  MOVF   3D,W
065B:  MOVWF  41
065C:  MOVF   3C,W
065D:  MOVWF  40
065E:  MOVF   3B,W
065F:  MOVWF  3F
....................      e_1=e; 
0660:  MOVF   3A,W
0661:  MOVWF  3E
0662:  MOVF   39,W
0663:  MOVWF  3D
0664:  MOVF   38,W
0665:  MOVWF  3C
0666:  MOVF   37,W
0667:  MOVWF  3B
....................      u_1=u; 
0668:  MOVF   46,W
0669:  MOVWF  4A
066A:  MOVF   45,W
066B:  MOVWF  49
066C:  MOVF   44,W
066D:  MOVWF  48
066E:  MOVF   43,W
066F:  MOVWF  47
....................       
....................      //La accion calculada la transformo en PWM 
....................      set_pwm1_duty(control); 
0670:  MOVF   2E,W
0671:  MOVWF  79
0672:  MOVF   2D,W
0673:  MOVWF  78
0674:  RRF    79,F
0675:  RRF    78,F
0676:  RRF    79,F
0677:  RRF    78,F
0678:  RRF    79,F
0679:  MOVF   78,W
067A:  MOVWF  15
067B:  RRF    79,F
067C:  RRF    79,W
067D:  ANDLW  30
067E:  MOVWF  77
067F:  MOVF   17,W
0680:  ANDLW  CF
0681:  IORWF  77,W
0682:  MOVWF  17
0683:  BCF    0A.3
0684:  BSF    0A.4
0685:  GOTO   3DC (RETURN)
....................       
.................... } 
....................  
....................  
.................... /*===========================================================================*/ 
.................... /*============   FUNCION PARA DIGITAR ESCALN/SETPOINT  =====================*/ 
.................... /*===========================================================================*/ 
.................... long escalon(int nd) 
.................... { 
....................    //Esta funcion captura el escalon desde el teclado, si el proceso est tomando 
....................    //datos el escalon sirve para exitar el sistema, por otro lado si el sistema 
....................    //est controlando, el escalo sirve para establecer el setpoint del sistema 
....................     
....................    long val; 
....................    int i; 
....................    char str[5]; //Variable tipo String 
....................     
....................    str[0]='0'; 
*
09A7:  MOVLW  30
09A8:  BSF    03.5
09A9:  MOVWF  31
....................    for(i=0;i<nd;i++) 
09AA:  CLRF   30
09AB:  MOVF   2D,W
09AC:  SUBWF  30,W
09AD:  BTFSC  03.0
09AE:  GOTO   1DC
....................    { 
....................        
....................       c=tecla();  //Lee el valor del teclado y espera hasta que alguna tecla se pulse 
*
09B9:  MOVF   78,W
09BA:  MOVWF  28
....................       if(c!='*'){ 
09BB:  MOVF   28,W
09BC:  SUBLW  2A
09BD:  BTFSC  03.2
09BE:  GOTO   1D8
....................          //Muestra el digito presionado en el LCD 
....................          lcd_gotoxy(5+i,4); 
09BF:  MOVLW  05
09C0:  ADDWF  30,W
09C1:  MOVWF  36
09C2:  MOVWF  3F
09C3:  MOVLW  04
09C4:  MOVWF  40
09C5:  BCF    0A.3
09C6:  BCF    03.5
09C7:  CALL   11B
09C8:  BSF    0A.3
....................          lcd_putc(c); 
09C9:  BSF    03.5
09CA:  MOVF   28,W
09CB:  MOVWF  3E
09CC:  BCF    0A.3
09CD:  BCF    03.5
09CE:  CALL   146
09CF:  BSF    0A.3
....................          //Almacena el dato presionado en la variable String 
....................          str[i]=c; 
09D0:  MOVLW  B1
09D1:  BSF    03.5
09D2:  ADDWF  30,W
09D3:  MOVWF  04
09D4:  BCF    03.7
09D5:  MOVF   28,W
09D6:  MOVWF  00
....................       } 
09D7:  GOTO   1DA
....................       else{i=nd;} //Si se presiona * sale del For       
09D8:  MOVF   2D,W
09D9:  MOVWF  30
09DA:  INCF   30,F
09DB:  GOTO   1AB
....................    } 
....................    val = atol(str); //Convierte el String en un valor numerico 
09DC:  CLRF   37
09DD:  MOVLW  B1
09DE:  MOVWF  36
*
0B16:  MOVF   79,W
0B17:  MOVWF  2F
0B18:  MOVF   78,W
0B19:  MOVWF  2E
....................    return(val); 
0B1A:  MOVF   2E,W
0B1B:  MOVWF  78
0B1C:  MOVF   2F,W
0B1D:  MOVWF  79
0B1E:  BCF    03.5
0B1F:  BCF    0A.3
0B20:  BSF    0A.4
0B21:  GOTO   52D (RETURN)
.................... } 
....................  
.................... void main() 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  CLRF   2E
1004:  CLRF   2D
1005:  CLRF   32
1006:  MOVLW  80
1007:  MOVWF  31
1008:  MOVLW  3B
1009:  MOVWF  30
100A:  MOVLW  89
100B:  MOVWF  2F
100C:  CLRF   36
100D:  CLRF   35
100E:  CLRF   34
100F:  CLRF   33
1010:  CLRF   3A
1011:  CLRF   39
1012:  CLRF   38
1013:  CLRF   37
1014:  CLRF   3E
1015:  CLRF   3D
1016:  CLRF   3C
1017:  CLRF   3B
1018:  CLRF   42
1019:  CLRF   41
101A:  CLRF   40
101B:  CLRF   3F
101C:  CLRF   46
101D:  CLRF   45
101E:  CLRF   44
101F:  CLRF   43
1020:  CLRF   4A
1021:  CLRF   49
1022:  CLRF   48
1023:  CLRF   47
1024:  MOVLW  CD
1025:  MOVWF  4E
1026:  MOVLW  CC
1027:  MOVWF  4D
1028:  MOVLW  4C
1029:  MOVWF  4C
102A:  MOVLW  7B
102B:  MOVWF  4B
102C:  MOVLW  C3
102D:  MOVWF  6A
102E:  MOVLW  F5
102F:  MOVWF  69
1030:  MOVLW  08
1031:  MOVWF  68
1032:  MOVLW  7E
1033:  MOVWF  67
1034:  CLRF   6E
1035:  CLRF   6D
1036:  MOVLW  20
1037:  MOVWF  6C
1038:  MOVLW  82
1039:  MOVWF  6B
103A:  CLRF   72
103B:  CLRF   71
103C:  CLRF   70
103D:  MOVLW  7F
103E:  MOVWF  6F
103F:  BSF    03.5
1040:  CLRF   29
1041:  MOVLW  FF
1042:  MOVWF  2A
1043:  CLRF   2C
1044:  CLRF   2B
1045:  BSF    03.6
1046:  MOVF   09,W
1047:  ANDLW  C0
1048:  MOVWF  09
1049:  BCF    03.6
104A:  BCF    1F.4
104B:  BCF    1F.5
104C:  MOVLW  00
104D:  BSF    03.6
104E:  MOVWF  08
104F:  BCF    03.5
1050:  CLRF   07
1051:  CLRF   08
1052:  CLRF   09
1053:  BCF    03.7
.................... { 
....................    port_b_pullups (0xFF);  //Utiliza las resistencias PULL UP internas del puerto B 
*
105B:  MOVLW  FF
105C:  BSF    03.5
105D:  MOVWF  15
105E:  BCF    01.7
....................     
....................    set_tris_c(0); 
105F:  MOVLW  00
1060:  MOVWF  07
1061:  MOVWF  2A
....................    set_tris_d(0); 
1062:  MOVWF  08
....................    setup_timer_2(t2_div_by_4,249,1);   //Configuracion de Timer 2 para establecer frec. PWM a 1kHz 
1063:  MOVWF  78
1064:  IORLW  05
1065:  BCF    03.5
1066:  MOVWF  12
1067:  MOVLW  F9
1068:  BSF    03.5
1069:  MOVWF  12
....................    setup_ccp1(ccp_pwm);                //Configurar modulo CCP1 en modo PWM 
106A:  BCF    2A.2
106B:  MOVF   2A,W
106C:  MOVWF  07
106D:  BCF    03.5
106E:  BCF    07.2
106F:  MOVLW  0C
1070:  MOVWF  17
1071:  BSF    03.5
1072:  CLRF   1B
1073:  CLRF   1C
1074:  MOVLW  01
1075:  MOVWF  1D
....................    set_pwm1_duty(0);                   //Dejo en cero la salida PWM 
1076:  BCF    03.5
1077:  CLRF   15
....................     
....................    setup_adc_ports(sAN0);              //Configurar ADC (Lectura de temperatura) 
1078:  BSF    03.5
1079:  BSF    03.6
107A:  MOVF   09,W
107B:  ANDLW  C0
107C:  MOVWF  09
107D:  BCF    03.6
107E:  BCF    1F.4
107F:  BCF    1F.5
1080:  MOVLW  01
1081:  BSF    03.6
1082:  MOVWF  08
....................    setup_adc(adc_clock_internal);      //Reloj interno para la conversion analoga digital) 
1083:  BCF    03.5
1084:  BCF    03.6
1085:  BSF    1F.6
1086:  BSF    1F.7
1087:  BSF    03.5
1088:  BSF    1F.7
1089:  BCF    03.5
108A:  BSF    1F.0
....................    set_adc_channel(0);                 //Seleccionar Canal 0 para sensor de Temperatura 
108B:  MOVLW  00
108C:  MOVWF  78
108D:  MOVF   1F,W
108E:  ANDLW  C3
108F:  IORWF  78,W
1090:  MOVWF  1F
....................     
....................     
....................    LCD_INIT();                         //Inicializo el LCD 
1091:  BCF    0A.4
1092:  GOTO   0E1
1093:  BSF    0A.4
....................    LCD_PUTC("\f");                     //Limpio el LCD 
1094:  MOVLW  20
1095:  BSF    03.6
1096:  MOVWF  0D
1097:  MOVLW  00
1098:  MOVWF  0F
1099:  BCF    0A.4
109A:  BCF    03.6
109B:  CALL   17B
109C:  BSF    0A.4
....................     
....................    //*************************************************************************// 
....................    //*************  DISEO POR ASIGNACIN DE 2 POLOS REALES   ****************// 
....................    //*************************************************************************// 
....................     
....................    TsMA=30;                    //Tiempo deseado en Lazo Cerrado     
109D:  CLRF   76
109E:  CLRF   75
109F:  MOVLW  70
10A0:  MOVWF  74
10A1:  MOVLW  83
10A2:  MOVWF  73
....................    Wn=5.8335/(TsMA);               //Frecuencia natural del sistema 
10A3:  MOVLW  08
10A4:  BSF    03.5
10A5:  MOVWF  3C
10A6:  MOVLW  AC
10A7:  MOVWF  3B
10A8:  MOVLW  3A
10A9:  MOVWF  3A
10AA:  MOVLW  81
10AB:  MOVWF  39
10AC:  MOVF   76,W
10AD:  MOVWF  40
10AE:  MOVF   75,W
10AF:  MOVWF  3F
10B0:  MOVF   74,W
10B1:  MOVWF  3E
10B2:  MOVF   73,W
10B3:  MOVWF  3D
10B4:  BCF    0A.4
10B5:  BCF    03.5
10B6:  CALL   1EF
10B7:  BSF    0A.4
10B8:  MOVF   7A,W
10B9:  MOVWF  7E
10BA:  MOVF   79,W
10BB:  MOVWF  7D
10BC:  MOVF   78,W
10BD:  MOVWF  7C
10BE:  MOVF   77,W
10BF:  MOVWF  7B
....................     
....................    //Ubicacin de 2 Polos reales 
....................    P1=2*Wn; 
10C0:  BSF    03.5
10C1:  CLRF   41
10C2:  CLRF   40
10C3:  CLRF   3F
10C4:  MOVLW  80
10C5:  MOVWF  3E
10C6:  MOVF   7E,W
10C7:  MOVWF  45
10C8:  MOVF   7D,W
10C9:  MOVWF  44
10CA:  MOVF   7C,W
10CB:  MOVWF  43
10CC:  MOVF   7B,W
10CD:  MOVWF  42
10CE:  BCF    0A.4
10CF:  BCF    03.5
10D0:  CALL   2BB
10D1:  BSF    0A.4
10D2:  MOVF   7A,W
10D3:  BSF    03.5
10D4:  MOVWF  23
10D5:  MOVF   79,W
10D6:  MOVWF  22
10D7:  MOVF   78,W
10D8:  MOVWF  21
10D9:  MOVF   77,W
10DA:  MOVWF  20
....................    P2=Wn*Wn; 
10DB:  MOVF   7E,W
10DC:  MOVWF  41
10DD:  MOVF   7D,W
10DE:  MOVWF  40
10DF:  MOVF   7C,W
10E0:  MOVWF  3F
10E1:  MOVF   7B,W
10E2:  MOVWF  3E
10E3:  MOVF   7E,W
10E4:  MOVWF  45
10E5:  MOVF   7D,W
10E6:  MOVWF  44
10E7:  MOVF   7C,W
10E8:  MOVWF  43
10E9:  MOVF   7B,W
10EA:  MOVWF  42
10EB:  BCF    0A.4
10EC:  BCF    03.5
10ED:  CALL   2BB
10EE:  BSF    0A.4
10EF:  MOVF   7A,W
10F0:  BSF    03.5
10F1:  MOVWF  27
10F2:  MOVF   79,W
10F3:  MOVWF  26
10F4:  MOVF   78,W
10F5:  MOVWF  25
10F6:  MOVF   77,W
10F7:  MOVWF  24
....................     
....................    kp=(P1*tao-1)/k;        //Calculo de Kc 
10F8:  MOVF   23,W
10F9:  MOVWF  41
10FA:  MOVF   22,W
10FB:  MOVWF  40
10FC:  MOVF   21,W
10FD:  MOVWF  3F
10FE:  MOVF   20,W
10FF:  MOVWF  3E
1100:  BCF    03.5
1101:  MOVF   6E,W
1102:  BSF    03.5
1103:  MOVWF  45
1104:  BCF    03.5
1105:  MOVF   6D,W
1106:  BSF    03.5
1107:  MOVWF  44
1108:  BCF    03.5
1109:  MOVF   6C,W
110A:  BSF    03.5
110B:  MOVWF  43
110C:  BCF    03.5
110D:  MOVF   6B,W
110E:  BSF    03.5
110F:  MOVWF  42
1110:  BCF    0A.4
1111:  BCF    03.5
1112:  CALL   2BB
1113:  BSF    0A.4
1114:  MOVF   7A,W
1115:  BSF    03.5
1116:  MOVWF  30
1117:  MOVF   79,W
1118:  MOVWF  2F
1119:  MOVF   78,W
111A:  MOVWF  2E
111B:  MOVF   77,W
111C:  MOVWF  2D
111D:  BSF    03.1
111E:  MOVF   30,W
111F:  MOVWF  38
1120:  MOVF   2F,W
1121:  MOVWF  37
1122:  MOVF   2E,W
1123:  MOVWF  36
1124:  MOVF   2D,W
1125:  MOVWF  35
1126:  CLRF   3C
1127:  CLRF   3B
1128:  CLRF   3A
1129:  MOVLW  7F
112A:  MOVWF  39
112B:  BCF    0A.4
112C:  BCF    03.5
112D:  CALL   332
112E:  BSF    0A.4
112F:  MOVF   7A,W
1130:  BSF    03.5
1131:  MOVWF  30
1132:  MOVF   79,W
1133:  MOVWF  2F
1134:  MOVF   78,W
1135:  MOVWF  2E
1136:  MOVF   77,W
1137:  MOVWF  2D
1138:  MOVF   30,W
1139:  MOVWF  3C
113A:  MOVF   2F,W
113B:  MOVWF  3B
113C:  MOVF   2E,W
113D:  MOVWF  3A
113E:  MOVF   2D,W
113F:  MOVWF  39
1140:  BCF    03.5
1141:  MOVF   6A,W
1142:  BSF    03.5
1143:  MOVWF  40
1144:  BCF    03.5
1145:  MOVF   69,W
1146:  BSF    03.5
1147:  MOVWF  3F
1148:  BCF    03.5
1149:  MOVF   68,W
114A:  BSF    03.5
114B:  MOVWF  3E
114C:  BCF    03.5
114D:  MOVF   67,W
114E:  BSF    03.5
114F:  MOVWF  3D
1150:  BCF    0A.4
1151:  BCF    03.5
1152:  CALL   1EF
1153:  BSF    0A.4
1154:  MOVF   7A,W
1155:  MOVWF  52
1156:  MOVF   79,W
1157:  MOVWF  51
1158:  MOVF   78,W
1159:  MOVWF  50
115A:  MOVF   77,W
115B:  MOVWF  4F
....................    ti=(k*kp)/(P2*tao);     //Calculo de ti 
115C:  MOVF   6A,W
115D:  BSF    03.5
115E:  MOVWF  41
115F:  BCF    03.5
1160:  MOVF   69,W
1161:  BSF    03.5
1162:  MOVWF  40
1163:  BCF    03.5
1164:  MOVF   68,W
1165:  BSF    03.5
1166:  MOVWF  3F
1167:  BCF    03.5
1168:  MOVF   67,W
1169:  BSF    03.5
116A:  MOVWF  3E
116B:  BCF    03.5
116C:  MOVF   52,W
116D:  BSF    03.5
116E:  MOVWF  45
116F:  BCF    03.5
1170:  MOVF   51,W
1171:  BSF    03.5
1172:  MOVWF  44
1173:  BCF    03.5
1174:  MOVF   50,W
1175:  BSF    03.5
1176:  MOVWF  43
1177:  BCF    03.5
1178:  MOVF   4F,W
1179:  BSF    03.5
117A:  MOVWF  42
117B:  BCF    0A.4
117C:  BCF    03.5
117D:  CALL   2BB
117E:  BSF    0A.4
117F:  MOVF   7A,W
1180:  BSF    03.5
1181:  MOVWF  30
1182:  MOVF   79,W
1183:  MOVWF  2F
1184:  MOVF   78,W
1185:  MOVWF  2E
1186:  MOVF   77,W
1187:  MOVWF  2D
1188:  MOVF   27,W
1189:  MOVWF  41
118A:  MOVF   26,W
118B:  MOVWF  40
118C:  MOVF   25,W
118D:  MOVWF  3F
118E:  MOVF   24,W
118F:  MOVWF  3E
1190:  BCF    03.5
1191:  MOVF   6E,W
1192:  BSF    03.5
1193:  MOVWF  45
1194:  BCF    03.5
1195:  MOVF   6D,W
1196:  BSF    03.5
1197:  MOVWF  44
1198:  BCF    03.5
1199:  MOVF   6C,W
119A:  BSF    03.5
119B:  MOVWF  43
119C:  BCF    03.5
119D:  MOVF   6B,W
119E:  BSF    03.5
119F:  MOVWF  42
11A0:  BCF    0A.4
11A1:  BCF    03.5
11A2:  CALL   2BB
11A3:  BSF    0A.4
11A4:  BSF    03.5
11A5:  MOVF   30,W
11A6:  MOVWF  3C
11A7:  MOVF   2F,W
11A8:  MOVWF  3B
11A9:  MOVF   2E,W
11AA:  MOVWF  3A
11AB:  MOVF   2D,W
11AC:  MOVWF  39
11AD:  MOVF   7A,W
11AE:  MOVWF  40
11AF:  MOVF   79,W
11B0:  MOVWF  3F
11B1:  MOVF   78,W
11B2:  MOVWF  3E
11B3:  MOVF   77,W
11B4:  MOVWF  3D
11B5:  BCF    0A.4
11B6:  BCF    03.5
11B7:  CALL   1EF
11B8:  BSF    0A.4
11B9:  MOVF   7A,W
11BA:  MOVWF  56
11BB:  MOVF   79,W
11BC:  MOVWF  55
11BD:  MOVF   78,W
11BE:  MOVWF  54
11BF:  MOVF   77,W
11C0:  MOVWF  53
....................     
....................    //*************************************************************************// 
....................    //*****************   DISEO POR CANCELACIN DE POLOS    *******************// 
....................    //*************************************************************************// 
....................    /* 
....................    TsMA=7.5;                  //Tiempo deseado en Lazo Cerrado  
....................    kp=(tao)/(TsMA*k);      //Calculo de Kc 
....................    ti=tao;                  //Calculo de Ti (Igual a la constante de tiempo) 
....................    td=0; 
....................    */ 
....................    //*************************************************************************// 
....................    //*****************   SINTONIA POR ZIEGLER y NICHOLS    *******************// 
....................    //*************************************************************************// 
....................    /* 
....................    kp=(1.2*tao)/(k*theta); 
....................    ti=2*theta; 
....................    td=0.5*theta; 
....................    */ 
....................    //*************************************************************************// 
....................     
....................   // Calculo do controle PID digital 
....................    q0=kp*(1+T/(2*ti)+td/T); 
11C1:  BSF    03.5
11C2:  CLRF   41
11C3:  CLRF   40
11C4:  CLRF   3F
11C5:  MOVLW  80
11C6:  MOVWF  3E
11C7:  BCF    03.5
11C8:  MOVF   56,W
11C9:  BSF    03.5
11CA:  MOVWF  45
11CB:  BCF    03.5
11CC:  MOVF   55,W
11CD:  BSF    03.5
11CE:  MOVWF  44
11CF:  BCF    03.5
11D0:  MOVF   54,W
11D1:  BSF    03.5
11D2:  MOVWF  43
11D3:  BCF    03.5
11D4:  MOVF   53,W
11D5:  BSF    03.5
11D6:  MOVWF  42
11D7:  BCF    0A.4
11D8:  BCF    03.5
11D9:  CALL   2BB
11DA:  BSF    0A.4
11DB:  MOVF   4E,W
11DC:  BSF    03.5
11DD:  MOVWF  3C
11DE:  BCF    03.5
11DF:  MOVF   4D,W
11E0:  BSF    03.5
11E1:  MOVWF  3B
11E2:  BCF    03.5
11E3:  MOVF   4C,W
11E4:  BSF    03.5
11E5:  MOVWF  3A
11E6:  BCF    03.5
11E7:  MOVF   4B,W
11E8:  BSF    03.5
11E9:  MOVWF  39
11EA:  MOVF   7A,W
11EB:  MOVWF  40
11EC:  MOVF   79,W
11ED:  MOVWF  3F
11EE:  MOVF   78,W
11EF:  MOVWF  3E
11F0:  MOVF   77,W
11F1:  MOVWF  3D
11F2:  BCF    0A.4
11F3:  BCF    03.5
11F4:  CALL   1EF
11F5:  BSF    0A.4
11F6:  BCF    03.1
11F7:  BSF    03.5
11F8:  CLRF   38
11F9:  CLRF   37
11FA:  CLRF   36
11FB:  MOVLW  7F
11FC:  MOVWF  35
11FD:  MOVF   7A,W
11FE:  MOVWF  3C
11FF:  MOVF   79,W
1200:  MOVWF  3B
1201:  MOVF   78,W
1202:  MOVWF  3A
1203:  MOVF   77,W
1204:  MOVWF  39
1205:  BCF    0A.4
1206:  BCF    03.5
1207:  CALL   332
1208:  BSF    0A.4
1209:  MOVF   7A,W
120A:  BSF    03.5
120B:  MOVWF  30
120C:  MOVF   79,W
120D:  MOVWF  2F
120E:  MOVF   78,W
120F:  MOVWF  2E
1210:  MOVF   77,W
1211:  MOVWF  2D
1212:  BCF    03.5
1213:  MOVF   5A,W
1214:  BSF    03.5
1215:  MOVWF  3C
1216:  BCF    03.5
1217:  MOVF   59,W
1218:  BSF    03.5
1219:  MOVWF  3B
121A:  BCF    03.5
121B:  MOVF   58,W
121C:  BSF    03.5
121D:  MOVWF  3A
121E:  BCF    03.5
121F:  MOVF   57,W
1220:  BSF    03.5
1221:  MOVWF  39
1222:  BCF    03.5
1223:  MOVF   4E,W
1224:  BSF    03.5
1225:  MOVWF  40
1226:  BCF    03.5
1227:  MOVF   4D,W
1228:  BSF    03.5
1229:  MOVWF  3F
122A:  BCF    03.5
122B:  MOVF   4C,W
122C:  BSF    03.5
122D:  MOVWF  3E
122E:  BCF    03.5
122F:  MOVF   4B,W
1230:  BSF    03.5
1231:  MOVWF  3D
1232:  BCF    0A.4
1233:  BCF    03.5
1234:  CALL   1EF
1235:  BSF    0A.4
1236:  BCF    03.1
1237:  BSF    03.5
1238:  MOVF   30,W
1239:  MOVWF  38
123A:  MOVF   2F,W
123B:  MOVWF  37
123C:  MOVF   2E,W
123D:  MOVWF  36
123E:  MOVF   2D,W
123F:  MOVWF  35
1240:  MOVF   7A,W
1241:  MOVWF  3C
1242:  MOVF   79,W
1243:  MOVWF  3B
1244:  MOVF   78,W
1245:  MOVWF  3A
1246:  MOVF   77,W
1247:  MOVWF  39
1248:  BCF    0A.4
1249:  BCF    03.5
124A:  CALL   332
124B:  BSF    0A.4
124C:  MOVF   52,W
124D:  BSF    03.5
124E:  MOVWF  41
124F:  BCF    03.5
1250:  MOVF   51,W
1251:  BSF    03.5
1252:  MOVWF  40
1253:  BCF    03.5
1254:  MOVF   50,W
1255:  BSF    03.5
1256:  MOVWF  3F
1257:  BCF    03.5
1258:  MOVF   4F,W
1259:  BSF    03.5
125A:  MOVWF  3E
125B:  MOVF   7A,W
125C:  MOVWF  45
125D:  MOVF   79,W
125E:  MOVWF  44
125F:  MOVF   78,W
1260:  MOVWF  43
1261:  MOVF   77,W
1262:  MOVWF  42
1263:  BCF    0A.4
1264:  BCF    03.5
1265:  CALL   2BB
1266:  BSF    0A.4
1267:  MOVF   7A,W
1268:  MOVWF  5E
1269:  MOVF   79,W
126A:  MOVWF  5D
126B:  MOVF   78,W
126C:  MOVWF  5C
126D:  MOVF   77,W
126E:  MOVWF  5B
....................    q1=-kp*(1-T/(2*ti)+(2*td)/T); 
126F:  MOVF   4F,W
1270:  BSF    03.5
1271:  MOVWF  2D
1272:  BCF    03.5
1273:  MOVF   50,W
1274:  XORLW  80
1275:  BSF    03.5
1276:  MOVWF  2E
1277:  BCF    03.5
1278:  MOVF   51,W
1279:  BSF    03.5
127A:  MOVWF  2F
127B:  BCF    03.5
127C:  MOVF   52,W
127D:  BSF    03.5
127E:  MOVWF  30
127F:  CLRF   41
1280:  CLRF   40
1281:  CLRF   3F
1282:  MOVLW  80
1283:  MOVWF  3E
1284:  BCF    03.5
1285:  MOVF   56,W
1286:  BSF    03.5
1287:  MOVWF  45
1288:  BCF    03.5
1289:  MOVF   55,W
128A:  BSF    03.5
128B:  MOVWF  44
128C:  BCF    03.5
128D:  MOVF   54,W
128E:  BSF    03.5
128F:  MOVWF  43
1290:  BCF    03.5
1291:  MOVF   53,W
1292:  BSF    03.5
1293:  MOVWF  42
1294:  BCF    0A.4
1295:  BCF    03.5
1296:  CALL   2BB
1297:  BSF    0A.4
1298:  MOVF   4E,W
1299:  BSF    03.5
129A:  MOVWF  3C
129B:  BCF    03.5
129C:  MOVF   4D,W
129D:  BSF    03.5
129E:  MOVWF  3B
129F:  BCF    03.5
12A0:  MOVF   4C,W
12A1:  BSF    03.5
12A2:  MOVWF  3A
12A3:  BCF    03.5
12A4:  MOVF   4B,W
12A5:  BSF    03.5
12A6:  MOVWF  39
12A7:  MOVF   7A,W
12A8:  MOVWF  40
12A9:  MOVF   79,W
12AA:  MOVWF  3F
12AB:  MOVF   78,W
12AC:  MOVWF  3E
12AD:  MOVF   77,W
12AE:  MOVWF  3D
12AF:  BCF    0A.4
12B0:  BCF    03.5
12B1:  CALL   1EF
12B2:  BSF    0A.4
12B3:  BSF    03.1
12B4:  BSF    03.5
12B5:  CLRF   38
12B6:  CLRF   37
12B7:  CLRF   36
12B8:  MOVLW  7F
12B9:  MOVWF  35
12BA:  MOVF   7A,W
12BB:  MOVWF  3C
12BC:  MOVF   79,W
12BD:  MOVWF  3B
12BE:  MOVF   78,W
12BF:  MOVWF  3A
12C0:  MOVF   77,W
12C1:  MOVWF  39
12C2:  BCF    0A.4
12C3:  BCF    03.5
12C4:  CALL   332
12C5:  BSF    0A.4
12C6:  MOVF   7A,W
12C7:  BSF    03.5
12C8:  MOVWF  34
12C9:  MOVF   79,W
12CA:  MOVWF  33
12CB:  MOVF   78,W
12CC:  MOVWF  32
12CD:  MOVF   77,W
12CE:  MOVWF  31
12CF:  CLRF   41
12D0:  CLRF   40
12D1:  CLRF   3F
12D2:  MOVLW  80
12D3:  MOVWF  3E
12D4:  BCF    03.5
12D5:  MOVF   5A,W
12D6:  BSF    03.5
12D7:  MOVWF  45
12D8:  BCF    03.5
12D9:  MOVF   59,W
12DA:  BSF    03.5
12DB:  MOVWF  44
12DC:  BCF    03.5
12DD:  MOVF   58,W
12DE:  BSF    03.5
12DF:  MOVWF  43
12E0:  BCF    03.5
12E1:  MOVF   57,W
12E2:  BSF    03.5
12E3:  MOVWF  42
12E4:  BCF    0A.4
12E5:  BCF    03.5
12E6:  CALL   2BB
12E7:  BSF    0A.4
12E8:  MOVF   7A,W
12E9:  BSF    03.5
12EA:  MOVWF  38
12EB:  MOVF   79,W
12EC:  MOVWF  37
12ED:  MOVF   78,W
12EE:  MOVWF  36
12EF:  MOVF   77,W
12F0:  MOVWF  35
12F1:  MOVF   38,W
12F2:  MOVWF  3C
12F3:  MOVF   37,W
12F4:  MOVWF  3B
12F5:  MOVF   36,W
12F6:  MOVWF  3A
12F7:  MOVF   35,W
12F8:  MOVWF  39
12F9:  BCF    03.5
12FA:  MOVF   4E,W
12FB:  BSF    03.5
12FC:  MOVWF  40
12FD:  BCF    03.5
12FE:  MOVF   4D,W
12FF:  BSF    03.5
1300:  MOVWF  3F
1301:  BCF    03.5
1302:  MOVF   4C,W
1303:  BSF    03.5
1304:  MOVWF  3E
1305:  BCF    03.5
1306:  MOVF   4B,W
1307:  BSF    03.5
1308:  MOVWF  3D
1309:  BCF    0A.4
130A:  BCF    03.5
130B:  CALL   1EF
130C:  BSF    0A.4
130D:  BCF    03.1
130E:  BSF    03.5
130F:  MOVF   34,W
1310:  MOVWF  38
1311:  MOVF   33,W
1312:  MOVWF  37
1313:  MOVF   32,W
1314:  MOVWF  36
1315:  MOVF   31,W
1316:  MOVWF  35
1317:  MOVF   7A,W
1318:  MOVWF  3C
1319:  MOVF   79,W
131A:  MOVWF  3B
131B:  MOVF   78,W
131C:  MOVWF  3A
131D:  MOVF   77,W
131E:  MOVWF  39
131F:  BCF    0A.4
1320:  BCF    03.5
1321:  CALL   332
1322:  BSF    0A.4
1323:  BSF    03.5
1324:  MOVF   30,W
1325:  MOVWF  41
1326:  MOVF   2F,W
1327:  MOVWF  40
1328:  MOVF   2E,W
1329:  MOVWF  3F
132A:  MOVF   2D,W
132B:  MOVWF  3E
132C:  MOVF   7A,W
132D:  MOVWF  45
132E:  MOVF   79,W
132F:  MOVWF  44
1330:  MOVF   78,W
1331:  MOVWF  43
1332:  MOVF   77,W
1333:  MOVWF  42
1334:  BCF    0A.4
1335:  BCF    03.5
1336:  CALL   2BB
1337:  BSF    0A.4
1338:  MOVF   7A,W
1339:  MOVWF  62
133A:  MOVF   79,W
133B:  MOVWF  61
133C:  MOVF   78,W
133D:  MOVWF  60
133E:  MOVF   77,W
133F:  MOVWF  5F
....................    q2=(kp*td)/T; 
1340:  MOVF   52,W
1341:  BSF    03.5
1342:  MOVWF  41
1343:  BCF    03.5
1344:  MOVF   51,W
1345:  BSF    03.5
1346:  MOVWF  40
1347:  BCF    03.5
1348:  MOVF   50,W
1349:  BSF    03.5
134A:  MOVWF  3F
134B:  BCF    03.5
134C:  MOVF   4F,W
134D:  BSF    03.5
134E:  MOVWF  3E
134F:  BCF    03.5
1350:  MOVF   5A,W
1351:  BSF    03.5
1352:  MOVWF  45
1353:  BCF    03.5
1354:  MOVF   59,W
1355:  BSF    03.5
1356:  MOVWF  44
1357:  BCF    03.5
1358:  MOVF   58,W
1359:  BSF    03.5
135A:  MOVWF  43
135B:  BCF    03.5
135C:  MOVF   57,W
135D:  BSF    03.5
135E:  MOVWF  42
135F:  BCF    0A.4
1360:  BCF    03.5
1361:  CALL   2BB
1362:  BSF    0A.4
1363:  MOVF   7A,W
1364:  BSF    03.5
1365:  MOVWF  30
1366:  MOVF   79,W
1367:  MOVWF  2F
1368:  MOVF   78,W
1369:  MOVWF  2E
136A:  MOVF   77,W
136B:  MOVWF  2D
136C:  MOVF   30,W
136D:  MOVWF  3C
136E:  MOVF   2F,W
136F:  MOVWF  3B
1370:  MOVF   2E,W
1371:  MOVWF  3A
1372:  MOVF   2D,W
1373:  MOVWF  39
1374:  BCF    03.5
1375:  MOVF   4E,W
1376:  BSF    03.5
1377:  MOVWF  40
1378:  BCF    03.5
1379:  MOVF   4D,W
137A:  BSF    03.5
137B:  MOVWF  3F
137C:  BCF    03.5
137D:  MOVF   4C,W
137E:  BSF    03.5
137F:  MOVWF  3E
1380:  BCF    03.5
1381:  MOVF   4B,W
1382:  BSF    03.5
1383:  MOVWF  3D
1384:  BCF    0A.4
1385:  BCF    03.5
1386:  CALL   1EF
1387:  BSF    0A.4
1388:  MOVF   7A,W
1389:  MOVWF  66
138A:  MOVF   79,W
138B:  MOVWF  65
138C:  MOVF   78,W
138D:  MOVWF  64
138E:  MOVF   77,W
138F:  MOVWF  63
....................        
....................    while(1) 
....................    {       
....................          adc=read_adc(); //Leer ADC 
1390:  BSF    1F.1
1391:  BTFSC  1F.1
1392:  GOTO   391
1393:  BSF    03.5
1394:  MOVF   1E,W
1395:  BCF    03.5
1396:  MOVWF  2B
1397:  MOVF   1E,W
1398:  MOVWF  2C
....................          yM=adc*5000.0/1024.0; 
1399:  MOVF   2C,W
139A:  BSF    03.5
139B:  MOVWF  2E
139C:  BCF    03.5
139D:  MOVF   2B,W
139E:  BSF    03.5
139F:  MOVWF  2D
13A0:  BCF    0A.4
13A1:  BCF    03.5
13A2:  CALL   478
13A3:  BSF    0A.4
13A4:  MOVF   7A,W
13A5:  BSF    03.5
13A6:  MOVWF  41
13A7:  MOVF   79,W
13A8:  MOVWF  40
13A9:  MOVF   78,W
13AA:  MOVWF  3F
13AB:  MOVF   77,W
13AC:  MOVWF  3E
13AD:  CLRF   45
13AE:  MOVLW  40
13AF:  MOVWF  44
13B0:  MOVLW  1C
13B1:  MOVWF  43
13B2:  MOVLW  8B
13B3:  MOVWF  42
13B4:  BCF    0A.4
13B5:  BCF    03.5
13B6:  CALL   2BB
13B7:  BSF    0A.4
13B8:  MOVF   7A,W
13B9:  BSF    03.5
13BA:  MOVWF  30
13BB:  MOVF   79,W
13BC:  MOVWF  2F
13BD:  MOVF   78,W
13BE:  MOVWF  2E
13BF:  MOVF   77,W
13C0:  MOVWF  2D
13C1:  MOVF   30,W
13C2:  MOVWF  3C
13C3:  MOVF   2F,W
13C4:  MOVWF  3B
13C5:  MOVF   2E,W
13C6:  MOVWF  3A
13C7:  MOVF   2D,W
13C8:  MOVWF  39
13C9:  CLRF   40
13CA:  CLRF   3F
13CB:  CLRF   3E
13CC:  MOVLW  89
13CD:  MOVWF  3D
13CE:  BCF    0A.4
13CF:  BCF    03.5
13D0:  CALL   1EF
13D1:  BSF    0A.4
13D2:  MOVF   7A,W
13D3:  MOVWF  36
13D4:  MOVF   79,W
13D5:  MOVWF  35
13D6:  MOVF   78,W
13D7:  MOVWF  34
13D8:  MOVF   77,W
13D9:  MOVWF  33
....................           
....................          //Llama la funcion del controlador PID 
....................          PID(); 
13DA:  BCF    0A.4
13DB:  GOTO   4D8
13DC:  BSF    0A.4
....................          //tiempo de muestreo 
....................          delay_ms(28); 
13DD:  MOVLW  1C
13DE:  BSF    03.5
13DF:  MOVWF  3F
13E0:  BCF    0A.4
13E1:  BCF    03.5
13E2:  CALL   074
13E3:  BSF    0A.4
....................           
....................             lcd_gotoxy(2,1); 
13E4:  MOVLW  02
13E5:  BSF    03.5
13E6:  MOVWF  3F
13E7:  MOVLW  01
13E8:  MOVWF  40
13E9:  BCF    0A.4
13EA:  BCF    03.5
13EB:  CALL   11B
13EC:  BSF    0A.4
....................             lcd_putc("CONTROL PID HORNO"); 
13ED:  MOVLW  21
13EE:  BSF    03.6
13EF:  MOVWF  0D
13F0:  MOVLW  00
13F1:  MOVWF  0F
13F2:  BCF    0A.4
13F3:  BCF    03.6
13F4:  CALL   17B
13F5:  BSF    0A.4
....................             lcd_gotoxy(1,2); 
13F6:  MOVLW  01
13F7:  BSF    03.5
13F8:  MOVWF  3F
13F9:  MOVLW  02
13FA:  MOVWF  40
13FB:  BCF    0A.4
13FC:  BCF    03.5
13FD:  CALL   11B
13FE:  BSF    0A.4
....................             printf(lcd_putc,"Set-Point  : %3.1f C   ",R/10); 
13FF:  MOVF   32,W
1400:  BSF    03.5
1401:  MOVWF  3C
1402:  BCF    03.5
1403:  MOVF   31,W
1404:  BSF    03.5
1405:  MOVWF  3B
1406:  BCF    03.5
1407:  MOVF   30,W
1408:  BSF    03.5
1409:  MOVWF  3A
140A:  BCF    03.5
140B:  MOVF   2F,W
140C:  BSF    03.5
140D:  MOVWF  39
140E:  CLRF   40
140F:  CLRF   3F
1410:  MOVLW  20
1411:  MOVWF  3E
1412:  MOVLW  82
1413:  MOVWF  3D
1414:  BCF    0A.4
1415:  BCF    03.5
1416:  CALL   1EF
1417:  BSF    0A.4
1418:  MOVF   7A,W
1419:  BSF    03.5
141A:  MOVWF  30
141B:  MOVF   79,W
141C:  MOVWF  2F
141D:  MOVF   78,W
141E:  MOVWF  2E
141F:  MOVF   77,W
1420:  MOVWF  2D
1421:  MOVLW  2A
1422:  BCF    03.5
1423:  BSF    03.6
1424:  MOVWF  0D
1425:  MOVLW  00
1426:  MOVWF  0F
1427:  BCF    03.0
1428:  MOVLW  0D
1429:  BSF    03.5
142A:  BCF    03.6
142B:  MOVWF  31
142C:  BCF    0A.4
142D:  BCF    03.5
142E:  CALL   686
142F:  BSF    0A.4
1430:  MOVLW  02
1431:  MOVWF  04
1432:  BSF    03.5
1433:  MOVF   30,W
1434:  MOVWF  34
1435:  MOVF   2F,W
1436:  MOVWF  33
1437:  MOVF   2E,W
1438:  MOVWF  32
1439:  MOVF   2D,W
143A:  MOVWF  31
143B:  MOVLW  01
143C:  MOVWF  35
143D:  BCF    0A.4
143E:  BSF    0A.3
143F:  BCF    03.5
1440:  CALL   000
1441:  BSF    0A.4
1442:  BCF    0A.3
1443:  MOVLW  33
1444:  BSF    03.6
1445:  MOVWF  0D
1446:  MOVLW  00
1447:  MOVWF  0F
1448:  BCF    03.0
1449:  MOVLW  05
144A:  BSF    03.5
144B:  BCF    03.6
144C:  MOVWF  31
144D:  BCF    0A.4
144E:  BCF    03.5
144F:  CALL   686
1450:  BSF    0A.4
....................             lcd_gotoxy(1,3); 
1451:  MOVLW  01
1452:  BSF    03.5
1453:  MOVWF  3F
1454:  MOVLW  03
1455:  MOVWF  40
1456:  BCF    0A.4
1457:  BCF    03.5
1458:  CALL   11B
1459:  BSF    0A.4
....................             printf(lcd_putc,"Temperatura: %3.1f C",yM/10);             
145A:  MOVF   36,W
145B:  BSF    03.5
145C:  MOVWF  3C
145D:  BCF    03.5
145E:  MOVF   35,W
145F:  BSF    03.5
1460:  MOVWF  3B
1461:  BCF    03.5
1462:  MOVF   34,W
1463:  BSF    03.5
1464:  MOVWF  3A
1465:  BCF    03.5
1466:  MOVF   33,W
1467:  BSF    03.5
1468:  MOVWF  39
1469:  CLRF   40
146A:  CLRF   3F
146B:  MOVLW  20
146C:  MOVWF  3E
146D:  MOVLW  82
146E:  MOVWF  3D
146F:  BCF    0A.4
1470:  BCF    03.5
1471:  CALL   1EF
1472:  BSF    0A.4
1473:  MOVF   7A,W
1474:  BSF    03.5
1475:  MOVWF  30
1476:  MOVF   79,W
1477:  MOVWF  2F
1478:  MOVF   78,W
1479:  MOVWF  2E
147A:  MOVF   77,W
147B:  MOVWF  2D
147C:  MOVLW  36
147D:  BCF    03.5
147E:  BSF    03.6
147F:  MOVWF  0D
1480:  MOVLW  00
1481:  MOVWF  0F
1482:  BCF    03.0
1483:  MOVLW  0D
1484:  BSF    03.5
1485:  BCF    03.6
1486:  MOVWF  31
1487:  BCF    0A.4
1488:  BCF    03.5
1489:  CALL   686
148A:  BSF    0A.4
148B:  MOVLW  02
148C:  MOVWF  04
148D:  BSF    03.5
148E:  MOVF   30,W
148F:  MOVWF  34
1490:  MOVF   2F,W
1491:  MOVWF  33
1492:  MOVF   2E,W
1493:  MOVWF  32
1494:  MOVF   2D,W
1495:  MOVWF  31
1496:  MOVLW  01
1497:  MOVWF  35
1498:  BCF    0A.4
1499:  BSF    0A.3
149A:  BCF    03.5
149B:  CALL   000
149C:  BSF    0A.4
149D:  BCF    0A.3
149E:  MOVLW  20
149F:  BSF    03.5
14A0:  MOVWF  3E
14A1:  BCF    0A.4
14A2:  BCF    03.5
14A3:  CALL   146
14A4:  BSF    0A.4
14A5:  MOVLW  43
14A6:  BSF    03.5
14A7:  MOVWF  3E
14A8:  BCF    0A.4
14A9:  BCF    03.5
14AA:  CALL   146
14AB:  BSF    0A.4
....................             lcd_gotoxy(1,4); 
14AC:  MOVLW  01
14AD:  BSF    03.5
14AE:  MOVWF  3F
14AF:  MOVLW  04
14B0:  MOVWF  40
14B1:  BCF    0A.4
14B2:  BCF    03.5
14B3:  CALL   11B
14B4:  BSF    0A.4
....................             printf(lcd_putc,"Ley Control: %ld   ",control); 
14B5:  MOVLW  41
14B6:  BSF    03.6
14B7:  MOVWF  0D
14B8:  MOVLW  00
14B9:  MOVWF  0F
14BA:  BCF    03.0
14BB:  MOVLW  0D
14BC:  BSF    03.5
14BD:  BCF    03.6
14BE:  MOVWF  31
14BF:  BCF    0A.4
14C0:  BCF    03.5
14C1:  CALL   686
14C2:  BSF    0A.4
14C3:  MOVLW  10
14C4:  MOVWF  04
14C5:  MOVF   2E,W
14C6:  BSF    03.5
14C7:  MOVWF  2E
14C8:  BCF    03.5
14C9:  MOVF   2D,W
14CA:  BSF    03.5
14CB:  MOVWF  2D
14CC:  BCF    0A.4
14CD:  BCF    03.5
14CE:  GOTO   751
14CF:  BSF    0A.4
14D0:  MOVLW  20
14D1:  BSF    03.5
14D2:  MOVWF  3E
14D3:  BCF    0A.4
14D4:  BCF    03.5
14D5:  CALL   146
14D6:  BSF    0A.4
14D7:  MOVLW  20
14D8:  BSF    03.5
14D9:  MOVWF  3E
14DA:  BCF    0A.4
14DB:  BCF    03.5
14DC:  CALL   146
14DD:  BSF    0A.4
14DE:  MOVLW  20
14DF:  BSF    03.5
14E0:  MOVWF  3E
14E1:  BCF    0A.4
14E2:  BCF    03.5
14E3:  CALL   146
14E4:  BSF    0A.4
....................   
....................          ;  
....................           
....................        
....................          c=tecla_time();   //Lee el valor del teclado pero solo espera un tiempo determinado 
14E5:  BCF    0A.4
14E6:  BSF    0A.3
14E7:  GOTO   181
14E8:  BSF    0A.4
14E9:  BCF    0A.3
14EA:  MOVF   78,W
14EB:  BSF    03.5
14EC:  MOVWF  28
....................          if(c=='D') 
14ED:  MOVF   28,W
14EE:  SUBLW  44
14EF:  BTFSS  03.2
14F0:  GOTO   5F8
....................          { 
....................             lcd_gotoxy(1,2); 
14F1:  MOVLW  01
14F2:  MOVWF  3F
14F3:  MOVLW  02
14F4:  MOVWF  40
14F5:  BCF    0A.4
14F6:  BCF    03.5
14F7:  CALL   11B
14F8:  BSF    0A.4
....................             LCD_PUTC("Referencia(0-300):"); 
14F9:  MOVLW  4B
14FA:  BSF    03.6
14FB:  MOVWF  0D
14FC:  MOVLW  00
14FD:  MOVWF  0F
14FE:  BCF    0A.4
14FF:  BCF    03.6
1500:  CALL   17B
1501:  BSF    0A.4
....................             lcd_gotoxy(1,3); 
1502:  MOVLW  01
1503:  BSF    03.5
1504:  MOVWF  3F
1505:  MOVLW  03
1506:  MOVWF  40
1507:  BCF    0A.4
1508:  BCF    03.5
1509:  CALL   11B
150A:  BSF    0A.4
....................             LCD_PUTC("y presione *"); 
150B:  MOVLW  55
150C:  BSF    03.6
150D:  MOVWF  0D
150E:  MOVLW  00
150F:  MOVWF  0F
1510:  BCF    0A.4
1511:  BCF    03.6
1512:  CALL   17B
1513:  BSF    0A.4
....................             lcd_gotoxy(1,4); 
1514:  MOVLW  01
1515:  BSF    03.5
1516:  MOVWF  3F
1517:  MOVLW  04
1518:  MOVWF  40
1519:  BCF    0A.4
151A:  BCF    03.5
151B:  CALL   11B
151C:  BSF    0A.4
....................             LCD_PUTC("SP:                     "); 
151D:  MOVLW  5C
151E:  BSF    03.6
151F:  MOVWF  0D
1520:  MOVLW  00
1521:  MOVWF  0F
1522:  BCF    0A.4
1523:  BCF    03.6
1524:  CALL   17B
1525:  BSF    0A.4
....................             R=escalon(3); //Llama la funcion para digitar el escalon de exitacion 
1526:  MOVLW  03
1527:  BSF    03.5
1528:  MOVWF  2D
1529:  BCF    0A.4
152A:  BSF    0A.3
152B:  BCF    03.5
152C:  GOTO   1A7
152D:  BSF    0A.4
152E:  BCF    0A.3
152F:  MOVF   79,W
1530:  BSF    03.5
1531:  MOVWF  2E
1532:  MOVF   78,W
1533:  MOVWF  2D
1534:  BCF    0A.4
1535:  BCF    03.5
1536:  CALL   478
1537:  BSF    0A.4
1538:  MOVF   7A,W
1539:  MOVWF  32
153A:  MOVF   79,W
153B:  MOVWF  31
153C:  MOVF   78,W
153D:  MOVWF  30
153E:  MOVF   77,W
153F:  MOVWF  2F
....................             //Valida si R esta entre 0 y 100 (Esto es otra forma de usar el if - else) 
....................             R =(R > 300) ? 3000:R*10; 
1540:  BSF    03.5
1541:  CLRF   30
1542:  CLRF   2F
1543:  MOVLW  16
1544:  MOVWF  2E
1545:  MOVLW  87
1546:  MOVWF  2D
1547:  BCF    03.5
1548:  MOVF   32,W
1549:  BSF    03.5
154A:  MOVWF  34
154B:  BCF    03.5
154C:  MOVF   31,W
154D:  BSF    03.5
154E:  MOVWF  33
154F:  BCF    03.5
1550:  MOVF   30,W
1551:  BSF    03.5
1552:  MOVWF  32
1553:  BCF    03.5
1554:  MOVF   2F,W
1555:  BSF    03.5
1556:  MOVWF  31
1557:  BCF    0A.4
1558:  BCF    03.5
1559:  CALL   497
155A:  BSF    0A.4
155B:  BTFSS  03.0
155C:  GOTO   565
155D:  MOVLW  8A
155E:  MOVWF  77
155F:  MOVLW  3B
1560:  MOVWF  78
1561:  MOVLW  80
1562:  MOVWF  79
1563:  CLRF   7A
1564:  GOTO   57E
1565:  MOVF   32,W
1566:  BSF    03.5
1567:  MOVWF  41
1568:  BCF    03.5
1569:  MOVF   31,W
156A:  BSF    03.5
156B:  MOVWF  40
156C:  BCF    03.5
156D:  MOVF   30,W
156E:  BSF    03.5
156F:  MOVWF  3F
1570:  BCF    03.5
1571:  MOVF   2F,W
1572:  BSF    03.5
1573:  MOVWF  3E
1574:  CLRF   45
1575:  CLRF   44
1576:  MOVLW  20
1577:  MOVWF  43
1578:  MOVLW  82
1579:  MOVWF  42
157A:  BCF    0A.4
157B:  BCF    03.5
157C:  CALL   2BB
157D:  BSF    0A.4
157E:  MOVF   7A,W
157F:  MOVWF  32
1580:  MOVF   79,W
1581:  MOVWF  31
1582:  MOVF   78,W
1583:  MOVWF  30
1584:  MOVF   77,W
1585:  MOVWF  2F
....................              
....................             //Muestra el SETPOINT en pantalla 
....................             lcd_gotoxy(1,4); 
1586:  MOVLW  01
1587:  BSF    03.5
1588:  MOVWF  3F
1589:  MOVLW  04
158A:  MOVWF  40
158B:  BCF    0A.4
158C:  BCF    03.5
158D:  CALL   11B
158E:  BSF    0A.4
....................             printf(lcd_putc,"SP: %3.1f         ",R/10); 
158F:  MOVF   32,W
1590:  BSF    03.5
1591:  MOVWF  3C
1592:  BCF    03.5
1593:  MOVF   31,W
1594:  BSF    03.5
1595:  MOVWF  3B
1596:  BCF    03.5
1597:  MOVF   30,W
1598:  BSF    03.5
1599:  MOVWF  3A
159A:  BCF    03.5
159B:  MOVF   2F,W
159C:  BSF    03.5
159D:  MOVWF  39
159E:  CLRF   40
159F:  CLRF   3F
15A0:  MOVLW  20
15A1:  MOVWF  3E
15A2:  MOVLW  82
15A3:  MOVWF  3D
15A4:  BCF    0A.4
15A5:  BCF    03.5
15A6:  CALL   1EF
15A7:  BSF    0A.4
15A8:  MOVF   7A,W
15A9:  BSF    03.5
15AA:  MOVWF  30
15AB:  MOVF   79,W
15AC:  MOVWF  2F
15AD:  MOVF   78,W
15AE:  MOVWF  2E
15AF:  MOVF   77,W
15B0:  MOVWF  2D
15B1:  MOVLW  69
15B2:  BCF    03.5
15B3:  BSF    03.6
15B4:  MOVWF  0D
15B5:  MOVLW  00
15B6:  MOVWF  0F
15B7:  BCF    03.0
15B8:  MOVLW  04
15B9:  BSF    03.5
15BA:  BCF    03.6
15BB:  MOVWF  31
15BC:  BCF    0A.4
15BD:  BCF    03.5
15BE:  CALL   686
15BF:  BSF    0A.4
15C0:  MOVLW  02
15C1:  MOVWF  04
15C2:  BSF    03.5
15C3:  MOVF   30,W
15C4:  MOVWF  34
15C5:  MOVF   2F,W
15C6:  MOVWF  33
15C7:  MOVF   2E,W
15C8:  MOVWF  32
15C9:  MOVF   2D,W
15CA:  MOVWF  31
15CB:  MOVLW  01
15CC:  MOVWF  35
15CD:  BCF    0A.4
15CE:  BSF    0A.3
15CF:  BCF    03.5
15D0:  CALL   000
15D1:  BSF    0A.4
15D2:  BCF    0A.3
15D3:  MOVLW  6D
15D4:  BSF    03.6
15D5:  MOVWF  0D
15D6:  MOVLW  00
15D7:  MOVWF  0F
15D8:  BSF    03.0
15D9:  MOVLW  09
15DA:  BSF    03.5
15DB:  BCF    03.6
15DC:  MOVWF  31
15DD:  BCF    0A.4
15DE:  BCF    03.5
15DF:  CALL   686
15E0:  BSF    0A.4
....................             delay_ms(2000); 
15E1:  MOVLW  08
15E2:  BSF    03.5
15E3:  MOVWF  2D
15E4:  MOVLW  FA
15E5:  MOVWF  3F
15E6:  BCF    0A.4
15E7:  BCF    03.5
15E8:  CALL   074
15E9:  BSF    0A.4
15EA:  BSF    03.5
15EB:  DECFSZ 2D,F
15EC:  GOTO   5E4
....................             LCD_PUTC("\f"); 
15ED:  MOVLW  73
15EE:  BCF    03.5
15EF:  BSF    03.6
15F0:  MOVWF  0D
15F1:  MOVLW  00
15F2:  MOVWF  0F
15F3:  BCF    0A.4
15F4:  BCF    03.6
15F5:  CALL   17B
15F6:  BSF    0A.4
15F7:  BSF    03.5
....................          } 
15F8:  BCF    03.5
15F9:  GOTO   390
....................    } 
.................... } 
15FA:  SLEEP

Configuration Fuses:
   Word  1: 2CE1   XT NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
